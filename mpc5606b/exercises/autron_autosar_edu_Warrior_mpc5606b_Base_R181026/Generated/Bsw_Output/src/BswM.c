/*******************************************************************************
**                                                                            **
**  (C) 2013 HYUNDAI AUTRON Co., Ltd.                                         **
**  Confidential Proprietary Information. Distribution Limited.               **
**  Do Not Copy Without Prior Permission                                      **
**                                                                            **
**  FILE-NAME : BswM.c                                                        **
**                                                                            **
**  PRODUCT   : AUTOSAR BswM Module                                           **
**                                                                            **
**  NOTE: This file is auto generated, do not edit this file manually.        **
**                                                                            **
********************************************************************************

********************************************************************************
**                      Generation Tool Information                           **
********************************************************************************
**  Tool Version: 2.5.3                                                       **
**                                                                            **
**  Change History: Refer log file (use -l option to generate log file)       **
**                                                                            **
********************************************************************************
**                      File Generation Information                           **
*******************************************************************************/

/*
 * INPUT FILE:    Configuration\ECU\Ecud_Os.arxml
 *                Configuration\ECU\Ecud_Com.arxml
 *                Configuration\ECU\Ecud_EcuM.arxml
 *                Configuration\ECU\Ecud_BswM.arxml
 *                Configuration\ECU\Ecud_ComM.arxml
 *                Configuration\ECU\Ecud_NvM.arxml
 * GENERATED ON:  This timestamp is removed.
 */

/*******************************************************************************
**                      Include Section                                       **
*******************************************************************************/
#include "BswM.h"
#include "BswM_Ram.h"
#include "SchM_BswM.h"

#if (BSWM_CANSM_ENABLED == STD_ON)
#include "BswM_CanSM.h"
#endif
#if (BSWM_LINSM_ENABLED == STD_ON)
#include "BswM_LinSM.h"
#endif
#if (BSWM_LINTP_ENABLED == STD_ON)
#include "BswM_LinTp.h"
#endif
#if (BSWM_FRSM_ENABLED == STD_ON)
#include "BswM_FrSM.h"
#endif
#if (BSWM_ETHSM_ENABLED == STD_ON)
#include "BswM_EthSM.h"
#endif
#if (BSWM_ECUM_ENABLED == STD_ON)
#include "BswM_EcuM.h"
#endif
#if (BSWM_COMM_ENABLED == STD_ON)
#include "BswM_ComM.h"
#endif
#if (BSWM_WDGM_ENABLED == STD_ON)
#include "BswM_WdgM.h"
#endif
#if (BSWM_DCM_ENABLED == STD_ON)
#include "BswM_Dcm.h"
#endif
#if (BSWM_NVM_ENABLED == STD_ON)
#include "BswM_NvM.h"
#endif
#if (BSWM_J1939DCM_ENABLED == STD_ON)
#include "BswM_J1939Dcm.h"
#endif
#if (BSWM_J1939NM_ENABLED == STD_ON)
#include "BswM_J1939Nm.h"
#endif

#if (BSWM_DEV_ERROR_DETECT == STD_ON)
#include "Det.h"
#endif

/*******************************************************************************
**                      Global Data                                           **
*******************************************************************************/

/*******************************************************************************
**                      Function Definitions                                  **
*******************************************************************************/
#define BSWM_START_SEC_CODE
#include "MemMap.h"

#if (BSWM_VERSION_INFO_API == STD_ON)
/*******************************************************************************
** Function Name        : BswM_GetVersionInfo                                 **
**                                                                            **
** Service ID           : 0x01                                                **
**                                                                            **
** Description          : This Service returns the version information of     **
**                        Bsw Mode Manager.                                   **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : None                                                **
**                                                                            **
** Output Parameters    : Std_VersionInfoType *VersionInfo                    **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
*******************************************************************************/

FUNC(void, BSWM_CODE) BswM_GetVersionInfo
 (P2VAR(Std_VersionInfoType, AUTOMATIC, BSWM_APPL_DATA)VersionInfo)
{
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)
  /* Check NULL pointer */
  if (NULL_PTR == VersionInfo)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_INSTANCE_ID,
      BSWM_GETVERSIONINFO_SID, BSWM_E_NULL_POINTER);
  }
  else
  #endif
  {
    /* Load the vendor Id */
    VersionInfo->vendorID = BSWM_VENDOR_ID;
    /* Load the module Id */
    VersionInfo->moduleID = BSWM_MODULE_ID;
    /* Load Software Major Version */
    VersionInfo->sw_major_version = BSWM_SW_MAJOR_VERSION;
    /* Load Software Minor Version */
    VersionInfo->sw_minor_version = BSWM_SW_MINOR_VERSION;
    /* Load Software Patch Version */
    VersionInfo->sw_patch_version = BSWM_SW_PATCH_VERSION;
  }
}
#endif /* (BSWM_VERSION_INFO_API == STD_ON) */


/*******************************************************************************
** Function Name        : BswM_InitializeRulePreviousResult                   **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This Service Initializes the previous rule          **
**                        evaluation result with configured init value.       **
**                                                                            **
** Reentrancy           : Non Reentrant                                       **
**                                                                            **
** Input Parameters     : BswM_RuleIdType RuleId                              **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaRuleEvaluation                            **
**                        Function(s) invoked :                               **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_InitializeRulePreviousResult
 (BswM_RuleIdType RuleId)
{
  #if (BSWM_TOTAL_RULES > BSWM_ZERO)
  /* Initialize previous rule evaluation result with the configured result */
  BswM_GaaRuleEvaluation[RuleId].ucRulePreviousResult =
    BswM_GaaRuleInitProperty[RuleId].ucRuleInitState;
  
  /* Initialize rule status as idle */
  BswM_GaaRuleEvaluation[RuleId].blRuleStatus = BSWM_IDLE;
  #endif
}

/*******************************************************************************
** Function Name        : BswM_MainFunction                                   **
**                                                                            **
** Service ID           : 0x03                                                **
**                                                                            **
** Description          : Main function of the BswM                           **
**                                                                            **
** Reentrancy           : Non Reentrant                                       **
**                                                                            **
** Input Parameters     : void                                                **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : void                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaRuleEvaluation                            **
**                                                                            **
**                        Function(s) invoked :                               **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_MainFunction(void)
{
  #if (BSWM_TOTAL_DEFERRED_RULES_OF_BSW_INDICATION > BSWM_ZERO)
  BswM_RuleIdType LddRuleId;
  uint8 LucId;
  
  /* Process main fuction only if module is initialized */
  if (BSWM_UNINITIALIZED != BswM_GblInitStatus)
  {

    for (LucId = BSWM_ZERO;
         LucId < BSWM_TOTAL_DEFERRED_RULES_OF_BSW_INDICATION; LucId++)
    {
      LddRuleId = BswM_GaaDeferredBswRuleIdList[LucId];
      
      if (BSWM_READY == BswM_GaaRuleEvaluation[LddRuleId].blRuleStatus)
      {
        /* Invoke the rule function using pRuleFunction[LddRuleId] */
        BswM_GaaRuleInitProperty[LddRuleId].pRuleFunction();
        /* Enter in Data Protection */
        SchM_Enter_BswM_RULESTATUS_PROTECTION();
        BswM_GaaRuleEvaluation[LddRuleId].blRuleStatus = BSWM_IDLE;
        SchM_Exit_BswM_RULESTATUS_PROTECTION();
      }
    }    
  } /* if (BSWM_UNINITIALIZED != BswM_GblInitStatus) */
  #endif
}

#if (BSWM_GENERIC_REQUEST_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_RequestMode                                    **
**                                                                            **
** Service ID           : 0x02                                                **
**                                                                            **
** Description          : Generic function call to request modes. This        **
**                        function shall only be used by other BSW modules    **
**                        that does not have a specific mode request          **
**                        interface.                                          **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : BswM_UserType requesting_user,                      **
**                        BswM_ModeType requested_mode                        **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaGenericRequestProperty                    **
**                          BswM_GaaGenericCurrentState                       **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_RequestMode
 (BswM_UserType requesting_user, BswM_ModeType requested_mode)
{
  #if (BSWM_TOTAL_PORTS_OF_GENERIC_REQUEST > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
      BSWM_GENERIC_CURRENTSTATE_SID, BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    /* Module is initialized */
    for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_GENERIC_REQUEST; LucId++)
    {
      /* If Network ID matches */
      if (BswM_GaaGenericRequestProperty[LucId].usModeRequesterId ==
        requesting_user)
      {
        #if (BSWM_DEV_ERROR_DETECT == STD_ON)
        if (BswM_GaaGenericRequestProperty[LucId].usRequestedModeMax < requested_mode)
        {
          /* The Det error is reported when mode is out of range */
          (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
            BSWM_GENERIC_CURRENTSTATE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
        }
        else
        #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaGenericCurrentState[LucId].usModeRequesterId = requesting_user;
          BswM_GaaGenericCurrentState[LucId].ddRequestedState = requested_mode;        
          BswM_GaaGenericCurrentState[LucId].blModeValueStatus = BSWM_VALID;          
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaGenericRequestProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaGenericRequestProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaGenericRequestProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(requesting_user);
  BSWM_UNUSED(requested_mode);
  #endif
}
#endif

#if (BSWM_CANSM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_CanSM_CurrentState                             **
**                                                                            **
** Service ID           : 0x05                                                **
**                                                                            **
** Description          : Function called by CanSM to indicate its current    **
**                        state.                                              **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NetworkHandleType Network,                          **
**                        CanSM_BswMCurrentStateType CurrentState             **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaCanSMIndicationProperty                   **
**                          BswM_GaaCanSMCurrentState                         **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_CanSM_CurrentState
 (NetworkHandleType Network, CanSM_BswMCurrentStateType CurrentState)
{
  #if (BSWM_TOTAL_PORTS_OF_CANSM_INDICATION > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
      BSWM_CANSM_CURRENTSTATE_SID, BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((CANSM_BSWM_NO_COMMUNICATION != CurrentState) &&
        (CANSM_BSWM_SILENT_COMMUNICATION != CurrentState) &&
        (CANSM_BSWM_FULL_COMMUNICATION != CurrentState) &&
        (CANSM_BSWM_BUS_OFF != CurrentState) &&
        (CANSM_BSWM_CHANGE_BAUDRATE != CurrentState))
    {
      /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_CANSM_CURRENTSTATE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_CANSM_INDICATION; LucId++)
      {
        /* If Network ID matches */
        if (BswM_GaaCanSMIndicationProperty[LucId].ddNetworkId == Network)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaCanSMCurrentState[LucId].ddCurrentState = CurrentState;
          BswM_GaaCanSMCurrentState[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaCanSMIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaCanSMIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaCanSMIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Network);
  BSWM_UNUSED(CurrentState);
  #endif
}
#endif

#if (BSWM_COMM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_ComM_CurrentMode                               **
**                                                                            **
** Service ID           : 0x0e                                                **
**                                                                            **
** Description          : Function called by ComM to indicate the current     **
**                        communication mode of a ComM channel.               **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NetworkHandleType Network,                          **
**                        ComM_ModeType RequestedMode                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaComMIndicationProperty                    **
**                          BswM_GaaComMCurrentMode                           **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_ComM_CurrentMode
 (NetworkHandleType Network, ComM_ModeType RequestedMode)
{
  #if (BSWM_TOTAL_PORTS_OF_COMM_INDICATION > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)  
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_COMM_CURRENTMODE_SID,
    BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((COMM_NO_COMMUNICATION != RequestedMode) &&
        (COMM_SILENT_COMMUNICATION != RequestedMode) &&
        (COMM_FULL_COMMUNICATION != RequestedMode))
    {
      /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_COMM_CURRENTMODE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_COMM_INDICATION; LucId++)
      {
        /* If Network ID matches */
        if (BswM_GaaComMIndicationProperty[LucId].ddNetworkId == Network)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaComMCurrentMode[LucId].ddCurrentMode = RequestedMode;
          BswM_GaaComMCurrentMode[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaComMIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaComMIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaComMIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Network);
  BSWM_UNUSED(RequestedMode);
  #endif
}
#endif

#if (BSWM_COMM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_ComM_CurrentPNCMode                            **
**                                                                            **
** Service ID           : 0x15                                                **
**                                                                            **
** Description          : Function called by ComM to indicate the current     **
**                        communication mode of a ComM channel.               **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : PNCHandleType PNC,                                  **
**                        ComM_PncModeType RequestedMode                      **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaComMPncIndicationProperty                 **
**                          BswM_GaaComMPNCCurrentMode                        **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_ComM_CurrentPNCMode
 (PNCHandleType PNC, ComM_PncModeType RequestedMode)
{
  #if (BSWM_TOTAL_PORTS_OF_COMM_PNC_REQUEST > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;

  #if (BSWM_DEV_ERROR_DETECT == STD_ON)
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_COMM_PNC_CURRENTMODE_SID,
    BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((PNC_REQUESTED != RequestedMode) &&
        (PNC_READY_SLEEP != RequestedMode) &&
        (PNC_PREPARE_SLEEP != RequestedMode) &&
        (PNC_NO_COMMUNICATION != RequestedMode) &&
        (PNC_FULL_COMMUNICATION != RequestedMode))
    {
      /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_COMM_PNC_CURRENTMODE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_COMM_PNC_REQUEST; LucId++)
      {
        /* If PNC ID matches */
        if (BswM_GaaComMPncIndicationProperty[LucId].ddNetworkId == PNC)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaComMPNCCurrentMode[LucId].ddCurrentMode = RequestedMode;
          BswM_GaaComMPNCCurrentMode[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaComMPncIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaComMPncIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaComMPncIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(PNC);
  BSWM_UNUSED(RequestedMode);
  #endif
}
#endif

#if (BSWM_DCM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_Dcm_CommunicationMode_CurrentState             **
**                                                                            **
** Service ID           : 0x06                                                **
**                                                                            **
** Description          : Function called by DCM to request communication     **
**                        modes.                                              **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NetworkHandleType Network,                          **
**                        Dcm_CommunicationModeType RequestedMode             **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaDcmComRequestProperty                     **
**                          BswM_GaaDcmReqCommunication                       **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_Dcm_CommunicationMode_CurrentState
 (NetworkHandleType Network, Dcm_CommunicationModeType RequestedMode)
{
  #if (BSWM_TOTAL_PORTS_OF_DCM_COM_REQUEST > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;

  #if (BSWM_DEV_ERROR_DETECT == STD_ON)  
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
      BSWM_DCM_REQUESTCOMMUNICATIONMODE_SID, BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((DCM_ENABLE_RX_TX_NORM != RequestedMode) &&
        (DCM_ENABLE_RX_DISABLE_TX_NORM != RequestedMode) &&
        (DCM_DISABLE_RX_ENABLE_TX_NORM != RequestedMode) &&
        (DCM_DISABLE_RX_TX_NORM != RequestedMode) &&
        (DCM_ENABLE_RX_TX_NM != RequestedMode) &&
        (DCM_ENABLE_RX_DISABLE_TX_NM != RequestedMode) &&
        (DCM_DISABLE_RX_ENABLE_TX_NM != RequestedMode) &&
        (DCM_DISABLE_RX_TX_NM != RequestedMode) &&
        (DCM_ENABLE_RX_TX_NORM_NM != RequestedMode) &&
        (DCM_ENABLE_RX_DISABLE_TX_NORM_NM != RequestedMode) &&
        (DCM_DISABLE_RX_ENABLE_TX_NORM_NM != RequestedMode) &&
        (DCM_DISABLE_RX_TX_NORM_NM != RequestedMode))
    {
      /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_DCM_REQUESTCOMMUNICATIONMODE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_DCM_COM_REQUEST; LucId++)
      {
        /* If Network ID matches */
        if (BswM_GaaDcmComRequestProperty[LucId].ddNetworkId == Network)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaDcmReqCommunication[LucId].ddRequestedMode = RequestedMode;
          BswM_GaaDcmReqCommunication[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaDcmComRequestProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaDcmComRequestProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaDcmComRequestProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Network);
  BSWM_UNUSED(RequestedMode);
  #endif
}
#endif

#if (BSWM_DCM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_Dcm_ApplicationUpdated                         **
**                                                                            **
** Service ID           : 0x23                                                **
**                                                                            **
** Description          : Function called by DCM to indicate application      **
**                        updated.                                            **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : None                                                **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaDcmApplicationUpdatedProperty             **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_Dcm_ApplicationUpdated(void)
{
  #if (BSWM_TOTAL_PORTS_OF_DCM_APPLICATION_UPDATED_INDICATION > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;

  #if (BSWM_DEV_ERROR_DETECT == STD_ON)
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
      BSWM_DCM_APPLICATIONUPDATED_SID, BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    /* Module is initialized */
    for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_DCM_APPLICATION_UPDATED_INDICATION; LucId++)
    {
      LpRuleId = BswM_GaaDcmApplicationUpdatedProperty[LucId].pRuleId;
      
      for (LddId = BSWM_ZERO; LddId < BswM_GaaDcmApplicationUpdatedProperty[LucId].ddTotalRules; LddId++)
      {
        if (BSWM_FALSE == 
            BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
        {
          /*
           * Update Rule Evaluation Status if the Request processing is deferred
           */
          if (BSWM_DEFERRED == 
              BswM_GaaDcmApplicationUpdatedProperty[LucId].blRequestProcessing)
          {
            /* Enter in Data Protection */
            SchM_Enter_BswM_RULESTATUS_PROTECTION();
            /* ucRuleResult, blRuleStatus */
            BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
            SchM_Exit_BswM_RULESTATUS_PROTECTION();
          }
          else
          {
            /* Invoke the rule function using pRuleFunction */
            /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
            BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
          }
        }
      }
    }
  }
  #endif
}
#endif

#if (BSWM_ECUM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_EcuM_CurrentState                              **
**                                                                            **
** Service ID           : 0x0f                                                **
**                                                                            **
** Description          : Function called by EcuM to indicate the current ECU **
**                        Operation Mode.                                     **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : EcuM_StateType CurrentState                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaEcuMIndicationProperty                    **
**                          BswM_GaaEcuMCurrentState                          **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_EcuM_CurrentState
 (EcuM_StateType CurrentState)
{
  #if (BSWM_TOTAL_PORTS_OF_ECUM_INDICATION > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;

  #if (BSWM_DEV_ERROR_DETECT == STD_ON)
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_ECUM_CURRENTSTATE_SID,
    BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((ECUM_STATE_STARTUP_ONE != CurrentState) &&
        (ECUM_STATE_STARTUP_TWO != CurrentState) &&
        (ECUM_STATE_WAKEUP_VALIDATION != CurrentState) &&
        (ECUM_STATE_PREP_SHUTDOWN != CurrentState) &&
        (ECUM_STATE_GO_SLEEP != CurrentState) &&
        (ECUM_STATE_GO_OFF_ONE != CurrentState))
    {
      /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_ECUM_CURRENTSTATE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_ECUM_INDICATION; LucId++)
      {
        /* Enter in Data Protection */
        SchM_Enter_BswM_DATA_PROTECTION();
        BswM_GaaEcuMCurrentState[LucId].ddCurrentState = CurrentState;
        BswM_GaaEcuMCurrentState[LucId].blModeValueStatus = BSWM_VALID;
        SchM_Exit_BswM_DATA_PROTECTION();
        
        LpRuleId = BswM_GaaEcuMIndicationProperty[LucId].pRuleId;
        
        for (LddId = BSWM_ZERO; LddId < BswM_GaaEcuMIndicationProperty[LucId].ddTotalRules; LddId++)
        {
          if (BSWM_FALSE == 
              BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
          {
            /* Update Rule Evaluation Status if the Request processing is deferred */
            if (BSWM_DEFERRED == 
                BswM_GaaEcuMIndicationProperty[LucId].blRequestProcessing)
            {
              /* Enter in Data Protection */
              SchM_Enter_BswM_RULESTATUS_PROTECTION();
              /* Set ready state */
              BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
              SchM_Exit_BswM_RULESTATUS_PROTECTION();
            }
            else
            {
              /* Invoke the rule function */
              /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
              BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(CurrentState);
  #endif
}
#endif

#if (BSWM_ECUM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_EcuM_CurrentWakeup                             **
**                                                                            **
** Service ID           : 0x10                                                **
**                                                                            **
** Description          : Function called by EcuM to indicate the current     **
**                        state of a wakeup source.                           **
**                        state.                                              **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : EcuM_WakeupSourceType source,                       **
**                        EcuM_WakeupStatusType state                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaEcuMWakeupIndicationProperty              **
**                          BswM_GaaEcuMCurrentWakeup                         **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
/* polyspace<MISRA-C:5.6:Not a defect:Justify with annotations> no impact of this rule violation (AUTOSAR Standard : BswM0131) */
FUNC(void, BSWM_CODE) BswM_EcuM_CurrentWakeup (EcuM_WakeupSourceType source, EcuM_WakeupStatusType state)
{
  #if (BSWM_TOTAL_PORTS_OF_ECUM_WAKEUP_SOURCE > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
      BSWM_ECUM_CURRENTWAKEUP_SID, BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((ECUM_WKSTATUS_DISABLED != state) &&
        (ECUM_WKSTATUS_EXPIRED != state) &&
        (ECUM_WKSTATUS_VALIDATED != state) &&
        (ECUM_WKSTATUS_PENDING != state) &&
        (ECUM_WKSTATUS_NONE != state))
    {
      /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_ECUM_CURRENTWAKEUP_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_ECUM_WAKEUP_SOURCE; LucId++)
      {
        /* If WakeUp Source ID matches */
        if ((BswM_GaaEcuMWakeupIndicationProperty[LucId].ddEcuMWakeupSourceId & source) != BSWM_ZERO)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaEcuMCurrentWakeup[LucId].ddState = state;
          BswM_GaaEcuMCurrentWakeup[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaEcuMWakeupIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaEcuMWakeupIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /* Update Rule Evaluation Status if the Request processing is deferred */
              if (BSWM_DEFERRED == 
                  BswM_GaaEcuMWakeupIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* Set ready state */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(source);
  BSWM_UNUSED(state);
  #endif
}
#endif

#if (BSWM_ETHSM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_EthSM_CurrentState                             **
**                                                                            **
** Service ID           : 0x0d                                                **
**                                                                            **
** Description          : Function called by EthSM to indicate its current    **
**                        state.                                              **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NetworkHandleType Network,                          **
**                        EthSM_NetworkModeStateType CurrentState             **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaEthSMIndicationProperty                   **
**                          BswM_GaaEthSMCurrentState                         **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_EthSM_CurrentState
 (NetworkHandleType Network, EthSM_NetworkModeStateType CurrentState)
{
  #if (BSWM_TOTAL_PORTS_OF_ETHSM_INDICATION > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)  
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
      BSWM_ETHSM_CURRENTSTATE_SID, BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((ETHSM_STATE_OFFLINE != CurrentState) &&
        (ETHSM_STATE_WAIT_TRCVLINK != CurrentState) &&
        (ETHSM_STATE_WAIT_ONLINE != CurrentState) &&
        (ETHSM_STATE_ONLINE != CurrentState) &&
        (ETHSM_STATE_ONHOLD != CurrentState) &&
        (ETHSM_STATE_WAIT_OFFLINE != CurrentState))
    {
      /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_ETHSM_CURRENTSTATE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_ETHSM_INDICATION; LucId++)
      {
        /* If Network ID matches */
        if (BswM_GaaEthSMIndicationProperty[LucId].ddNetworkId == Network)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaEthSMCurrentState[LucId].ddCurrentState = CurrentState;
          BswM_GaaEthSMCurrentState[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaEthSMIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaEthSMIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaEthSMIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Network);
  BSWM_UNUSED(CurrentState);
  #endif
}
#endif

#if (BSWM_FRSM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_FrSM_CurrentState                              **
**                                                                            **
** Service ID           : 0x0c                                                **
**                                                                            **
** Description          : Function called by FrSM to indicate its current     **
**                        state.                                              **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NetworkHandleType Network,                          **
**                        FrSM_BswM_StateType CurrentState                    **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaFrSMIndicationProperty                    **
**                          BswM_GaaFrSMCurrentState                          **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_FrSM_CurrentState
 (NetworkHandleType Network, FrSM_BswM_StateType CurrentState)
{
  #if (BSWM_TOTAL_PORTS_OF_FRSM_INDICATION > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;

  #if (BSWM_DEV_ERROR_DETECT == STD_ON)  
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_FRSM_CURRENTSTATE_SID,
      BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((FRSM_BSWM_READY != CurrentState) &&
        (FRSM_BSWM_READY_ECU_PASSIVE != CurrentState) &&
        (FRSM_BSWM_STARTUP != CurrentState) &&
        (FRSM_BSWM_STARTUP_ECU_PASSIVE != CurrentState) &&
        (FRSM_BSWM_WAKEUP != CurrentState) &&
        (FRSM_BSWM_WAKEUP_ECU_PASSIVE != CurrentState) &&
        (FRSM_BSWM_HALT_REQ != CurrentState) &&
        (FRSM_BSWM_HALT_REQ_ECU_PASSIVE != CurrentState) &&
        (FRSM_BSWM_KEYSLOT_ONLY != CurrentState) &&
        (FRSM_BSWM_KEYSLOT_ONLY_ECU_PASSIVE != CurrentState) &&
        (FRSM_BSWM_ONLINE != CurrentState) &&
        (FRSM_BSWM_ONLINE_ECU_PASSIVE != CurrentState) &&
        (FRSM_BSWM_ONLINE_PASSIVE != CurrentState) &&
        (FRSM_BSWM_ONLINE_PASSIVE_ECU_PASSIVE != CurrentState) &&
        (FRSM_LOW_NUMBER_OF_COLDSTARTERS != CurrentState) &&
        (FRSM_LOW_NUMBER_OF_COLDSTARTERS_ECU_PASSIVE != CurrentState))
    {
      /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_FRSM_CURRENTSTATE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_FRSM_INDICATION; LucId++)
      {
        /* If Network ID matches */
        if (BswM_GaaFrSMIndicationProperty[LucId].ddNetworkId == Network)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaFrSMCurrentState[LucId].ddCurrentState = CurrentState;
          BswM_GaaFrSMCurrentState[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaFrSMIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaFrSMIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaFrSMIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Network);
  BSWM_UNUSED(CurrentState);
  #endif
}
#endif

#if (BSWM_LINSM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_LinSM_CurrentState                             **
**                                                                            **
** Service ID           : 0x09                                                **
**                                                                            **
** Description          : Function called by LinSM to indicate its current    **
**                        state.                                              **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NetworkHandleType Network,                          **
**                        LinSM_ModeType CurrentState                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaLinSMIndicationProperty                   **
**                          BswM_GaaLinSMCurrentState                         **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_LinSM_CurrentState
 (NetworkHandleType Network, LinSM_ModeType CurrentState)
{
  #if (BSWM_TOTAL_PORTS_OF_LINSM_INDICATION > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON) 
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
      BSWM_LINSM_CURRENTSTATE_SID, BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((LINSM_NO_COM != CurrentState) &&
        (LINSM_FULL_COM != CurrentState))
    {
     /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_LINSM_CURRENTSTATE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_LINSM_INDICATION; LucId++)
      {
        /* If Network ID matches */
        if (BswM_GaaLinSMIndicationProperty[LucId].ddNetworkId == Network)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaLinSMCurrentState[LucId].ddCurrentState = CurrentState;
          BswM_GaaLinSMCurrentState[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaLinSMIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaLinSMIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaLinSMIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Network);
  BSWM_UNUSED(CurrentState);
  #endif
}
#endif

#if (BSWM_LINSM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_LinSM_CurrentSchedule                          **
**                                                                            **
** Service ID           : 0x0a                                                **
**                                                                            **
** Description          : Function called by LinSM to indicate the currently  **
**                        active schedule table for a specific LIN channel.   **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NetworkHandleType Network,                          **
**                        LinIf_SchHandleType CurrentSchedule                 **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaLinScheduleIndicationProperty             **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_LinSM_CurrentSchedule
 (NetworkHandleType Network, LinIf_SchHandleType CurrentSchedule)
{
  #if (BSWM_TOTAL_PORTS_OF_LIN_SCHEDULE_INDICATION > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;

  #if (BSWM_DEV_ERROR_DETECT == STD_ON) 
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
      BSWM_LINSM_CURRENTSCHEDULE_SID, BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ( BSWM_FALSE )
    {
       /* Report to DET */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_LINSM_CURRENTSCHEDULE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_LIN_SCHEDULE_INDICATION; LucId++)
      {
        /* If Network ID and Schedule ID match */
        if ((BswM_GaaLinScheduleIndicationProperty[LucId].ddNetworkId == Network) &&
            (BswM_GaaLinScheduleIndicationProperty[LucId].ucScheduleId == CurrentSchedule))
        {
          LpRuleId = BswM_GaaLinScheduleIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaLinScheduleIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaLinScheduleIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Network);
  BSWM_UNUSED(CurrentSchedule);
  #endif
}
#endif

#if (BSWM_LINTP_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_LinTp_RequestMode                              **
**                                                                            **
** Service ID           : 0x0b                                                **
**                                                                            **
** Description          : Function called by LinTP to request a mode for the  **
**                        corresponding LIN channel. The LinTp_Mode mainly    **
**                        correlates to the LIN schedule table that should    **
**                        be used.                                            **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NetworkHandleType Network,                          **
**                        LinTp_Mode LinTpRequestedMode                       **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaLinTpModeRequestProperty                  **
**                          BswM_GaaLinTpRequestMode                          **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_LinTp_RequestMode
 (NetworkHandleType Network, LinTp_Mode LinTpRequestedMode)
{
  #if (BSWM_TOTAL_PORTS_OF_LINTP_MODE_REQUEST > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;

  #if (BSWM_DEV_ERROR_DETECT == STD_ON)  
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_LINTP_REQUESTMODE_SID,
      BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((LINTP_APPLICATIVE_SCHEDULE != LinTpRequestedMode) &&
        (LINTP_DIAG_REQUEST != LinTpRequestedMode) &&
        (LINTP_DIAG_RESPONSE != LinTpRequestedMode))
    {
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_LINTP_REQUESTMODE_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_LINTP_MODE_REQUEST; LucId++)
      {
        /* If Network ID matches */
        if (BswM_GaaLinTpModeRequestProperty[LucId].ddNetworkId == Network)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaLinTpRequestMode[LucId].ddLinTpRequestedMode =
            LinTpRequestedMode;
          BswM_GaaLinTpRequestMode[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaLinTpModeRequestProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaLinTpModeRequestProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaLinTpModeRequestProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Network);
  BSWM_UNUSED(LinTpRequestedMode);
  #endif
}
#endif

#if (BSWM_NVM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_NvM_CurrentBlockMode                           **
**                                                                            **
** Service ID           : 0x16                                                **
**                                                                            **
** Description          : Function called by NvM to indicate the current      **
**                        block mode of an NvM block.                         **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NvM_BlockIdType Block,                              **
**                        NvM_RequestResultType CurrentBlockMode              **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaNvMBlockModeIndicationProperty            **
**                          BswM_GaaNvMCurrentBlockMode                       **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_NvM_CurrentBlockMode
 (NvM_BlockIdType Block, NvM_RequestResultType CurrentBlockMode)
{
  #if (BSWM_TOTAL_PORTS_OF_NVM_CURRENT_BLOCK_MODE > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;

  #if (BSWM_DEV_ERROR_DETECT == STD_ON) 
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_NVM_CURRENT_BLOCK_SID,
    BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((NVM_REQ_OK != CurrentBlockMode) &&
        (NVM_REQ_NOT_OK != CurrentBlockMode) &&
        (NVM_REQ_PENDING != CurrentBlockMode) &&
        (NVM_REQ_INTEGRITY_FAILED != CurrentBlockMode) &&
        (NVM_REQ_BLOCK_SKIPPED != CurrentBlockMode) &&
        (NVM_REQ_NV_INVALIDATED != CurrentBlockMode) &&
        (NVM_REQ_CANCELED != CurrentBlockMode) &&
        (NVM_REQ_REDUNDANCY_FAILED != CurrentBlockMode) &&
        (NVM_REQ_RESTORED_FROM_ROM != CurrentBlockMode))
    {
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_NVM_CURRENT_BLOCK_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_NVM_CURRENT_BLOCK_MODE; LucId++)
      {
        /* If Network ID matches */
        if (BswM_GaaNvMBlockModeIndicationProperty[LucId].ddBlockId == Block)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaNvMCurrentBlockMode[LucId].ddCurrentBlockMode = CurrentBlockMode;
          BswM_GaaNvMCurrentBlockMode[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaNvMBlockModeIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaNvMBlockModeIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaNvMBlockModeIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Block);
  BSWM_UNUSED(CurrentBlockMode);
  #endif
}
#endif

#if (BSWM_NVM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_NvM_CurrentJobMode                             **
**                                                                            **
** Service ID           : 0x17                                                **
**                                                                            **
** Description          : Function called by NvM to inform the BswM about     **
**                        the current state of a multi block job.             **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : uint8 ServiceId,                                    **
**                        NvM_RequestResultType CurrentBlockMode              **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaNvMJobModeIndicationProperty              **
**                          BswM_GaaNvMCurrentJobMode                         **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_NvM_CurrentJobMode
 (uint8 ServiceId, NvM_RequestResultType CurrentJobMode)
{
  #if (BSWM_TOTAL_PORTS_OF_NVM_CURRENT_JOB_MODE > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_NVM_CURRENT_JOB_SID,
    BSWM_E_NO_INIT);
  }
  else
  #endif
  { 
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((NVM_READALL_SID != ServiceId) &&
        (NVM_WRITEALL_SID != ServiceId))
    {
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_NVM_CURRENT_JOB_SID, BSWM_E_REQ_USER_OUT_OF_RANGE);
    }
    else if ((NVM_REQ_OK != CurrentJobMode) &&
             (NVM_REQ_NOT_OK != CurrentJobMode) &&
             (NVM_REQ_PENDING != CurrentJobMode) &&
             (NVM_REQ_INTEGRITY_FAILED != CurrentJobMode) &&
             (NVM_REQ_BLOCK_SKIPPED != CurrentJobMode) &&
             (NVM_REQ_NV_INVALIDATED != CurrentJobMode) &&
             (NVM_REQ_CANCELED != CurrentJobMode) &&
             (NVM_REQ_REDUNDANCY_FAILED != CurrentJobMode) &&
             (NVM_REQ_RESTORED_FROM_ROM != CurrentJobMode))
    {
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_NVM_CURRENT_JOB_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_NVM_CURRENT_JOB_MODE; LucId++)
      {
        /* If Network ID matches */
        if (BswM_GaaNvMJobModeIndicationProperty[LucId].ucServiceId == ServiceId)
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaNvMCurrentJobMode[LucId].ddCurrentJobMode = CurrentJobMode;
          BswM_GaaNvMCurrentJobMode[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();

          LpRuleId = BswM_GaaNvMJobModeIndicationProperty[LucId].pRuleId;

          for (LddId = BSWM_ZERO; LddId < BswM_GaaNvMJobModeIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaNvMJobModeIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(ServiceId);
  BSWM_UNUSED(CurrentJobMode);
  #endif
}
#endif

#if (BSWM_WDGM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_WdgM_RequestPartitionReset                     **
**                                                                            **
** Service ID           : 0x11                                                **
**                                                                            **
** Description          : Function called by WdgM to request a partition reset**
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : ApplicationType Application                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GaaWdgMPartitionResetProperty                **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
**                          pRuleFunction                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_WdgM_RequestPartitionReset
 (ApplicationType Application)
{
  #if (BSWM_TOTAL_PORTS_OF_WDGM_REQUEST_PARTITION_RESET > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_WDGM_REQUESTPARTITIONRESET_SID,
    BSWM_E_NO_INIT);
  }
  else
  #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
  {
    /* Module is initialized */
    for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_WDGM_REQUEST_PARTITION_RESET; LucId++)
    {
      /* If Network ID matches */
      if (BswM_GaaWdgMPartitionResetProperty[LucId].ddApplication == Application)
      {
        LpRuleId = BswM_GaaWdgMPartitionResetProperty[LucId].pRuleId;
        
        for (LddId = BSWM_ZERO; LddId < BswM_GaaWdgMPartitionResetProperty[LucId].ddTotalRules; LddId++)
        {
          if (BSWM_FALSE == 
              BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
          {
            /*
             * Update Rule Evaluation Status if the Request processing is deferred
             */
            if (BSWM_DEFERRED == 
                BswM_GaaWdgMPartitionResetProperty[LucId].blRequestProcessing)
            {
              /* Enter in Data Protection */
              SchM_Enter_BswM_RULESTATUS_PROTECTION();
              /* ucRuleResult, blRuleStatus */
              BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
              SchM_Exit_BswM_RULESTATUS_PROTECTION();
            }
            else
            {
              /* Invoke the rule function using pRuleFunction */
              /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
              BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Application);
  #endif
}
#endif

#if (BSWM_J1939DCM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_J1939DcmBroadcastStatus                        **
**                                                                            **
** Service ID           : 0x1B                                                **
**                                                                            **
** Description          : This API tells the BswM the desired communication   **
**                        status of the available networks. The status will   **
**                        typically be activated via COM I-PDU group switches.**
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : NetworkMask                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              :                                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_J1939DcmBroadcastStatus
 (uint16 NetworkMask)
{
  #if (BSWM_TOTAL_PORTS_OF_J1939DCM_BROADCAST_STATUS > BSWM_ZERO)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)  
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_J1939DCMBROADCASTSTATUS_SID,
    BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    /* Module is initialized */
    for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_J1939DCM_BROADCAST_STATUS; LucId++)
    {
      /* Enter in Data Protection */
      SchM_Enter_BswM_DATA_PROTECTION();
      BswM_GaaJ1939CurrentDcmStatus[LucId].ddCurrentMode = NetworkMask;
      BswM_GaaJ1939CurrentDcmStatus[LucId].blModeValueStatus = BSWM_VALID;
      SchM_Exit_BswM_DATA_PROTECTION();
      
      LpRuleId = BswM_GaaJ1939DcmBroadcastStatusProperty[LucId].pRuleId;
      
      for (LddId = BSWM_ZERO; LddId < BswM_GaaJ1939DcmBroadcastStatusProperty[LucId].ddTotalRules; LddId++)
      {
        if (BSWM_FALSE == 
            BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
        {
          /*
           * Update Rule Evaluation Status if the Request processing is deferred
           */
          if (BSWM_DEFERRED == 
              BswM_GaaJ1939DcmBroadcastStatusProperty[LucId].blRequestProcessing)
          {
            /* Enter in Data Protection */
            SchM_Enter_BswM_RULESTATUS_PROTECTION();
            /* ucRuleResult, blRuleStatus */
            BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
            SchM_Exit_BswM_RULESTATUS_PROTECTION();
          }
          else
          {
            /* Invoke the rule function using pRuleFunction */
            /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
            BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(NetworkMask);
  #endif
}
#endif

#if (BSWM_J1939NM_ENABLED == STD_ON)
/*******************************************************************************
** Function Name        : BswM_J1939Nm_StateChangeNotification                **
**                                                                            **
** Service ID           : 0x18                                                **
**                                                                            **
** Description          : Notification of current J1939Nm state after state   **
**                        changes.                                            **
**                                                                            **
** Reentrancy           : Reentrant                                           **
**                                                                            **
** Input Parameters     : Network Node NmState                                **
**                                                                            **
** Output Parameters    :                                                     **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              :                                                     **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_J1939Nm_StateChangeNotification
 (NetworkHandleType Network,
  uint8 Node,
  Nm_StateType NmState)
{
  #if (BSWM_TOTAL_PORTS_OF_J1939NM_INDICATION > 0)
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  
  #if (BSWM_DEV_ERROR_DETECT == STD_ON)  
  /* Is module not initialized */
  if (BSWM_INITIALIZED != BswM_GblInitStatus)
  {
    /* Report to DET */
    (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO, BSWM_J1939NM_STATECHANGENOTIFICATION_SID,
    BSWM_E_NO_INIT);
  }
  else
  #endif
  {
    #if (BSWM_DEV_ERROR_DETECT == STD_ON)
    if ((NmState != NM_STATE_UNINIT) &&
        (NmState != NM_STATE_BUS_SLEEP) &&
        (NmState != NM_STATE_PREPARE_BUS_SLEEP) &&
        (NmState != NM_STATE_READY_SLEEP) &&
        (NmState != NM_STATE_NORMAL_OPERATION) &&
        (NmState != NM_STATE_REPEAT_MESSAGE) &&
        (NmState != NM_STATE_SYNCHRONIZE) &&
        (NmState != NM_STATE_OFFLINE))
    {
      /* The Det error is reported when mode is out of range */
      (void)Det_ReportError(BSWM_MODULE_ID, BSWM_ZERO,
        BSWM_J1939NM_STATECHANGENOTIFICATION_SID, BSWM_E_REQ_MODE_OUT_OF_RANGE);
    }
    else
    #endif /* #if (BSWM_DEV_ERROR_DETECT == STD_ON) */
    {
      /* Module is initialized */
      for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_J1939NM_INDICATION; LucId++)
      {
        /* If Network ID, Node matches */
        if ((BswM_GaaJ1939NmIndicationProperty[LucId].ddNetworkId == Network) &&
            (BswM_GaaJ1939NmIndicationProperty[LucId].ucNodeId == Node))
        {
          /* Enter in Data Protection */
          SchM_Enter_BswM_DATA_PROTECTION();
          BswM_GaaJ1939CurrentNmMode[LucId].ddCurrentMode = NmState;
          BswM_GaaJ1939CurrentNmMode[LucId].blModeValueStatus = BSWM_VALID;
          SchM_Exit_BswM_DATA_PROTECTION();
          
          LpRuleId = BswM_GaaJ1939NmIndicationProperty[LucId].pRuleId;
          
          for (LddId = BSWM_ZERO; LddId < BswM_GaaJ1939NmIndicationProperty[LucId].ddTotalRules; LddId++)
          {
            if (BSWM_FALSE == 
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].blNestedExecutionOnly)
            {
              /*
               * Update Rule Evaluation Status if the Request processing is deferred
               */
              if (BSWM_DEFERRED == 
                  BswM_GaaJ1939NmIndicationProperty[LucId].blRequestProcessing)
              {
                /* Enter in Data Protection */
                SchM_Enter_BswM_RULESTATUS_PROTECTION();
                /* ucRuleResult, blRuleStatus */
                BswM_GaaRuleEvaluation[LpRuleId[LddId]].blRuleStatus = BSWM_READY;
                SchM_Exit_BswM_RULESTATUS_PROTECTION();
              }
              else
              {
                /* Invoke the rule function using pRuleFunction */
                /* polyspace<RTE: COR : Not a defect : No Action Planned> Function pointer points to a valid function */
                BswM_GaaRuleInitProperty[LpRuleId[LddId]].pRuleFunction();
              }
            }
          }
        }
      }
    }
  }
  #else
  BSWM_UNUSED(Network);
  BSWM_UNUSED(Node);
  BSWM_UNUSED(NmState);
  #endif
}
#endif

/*******************************************************************************
** Function Name        : BswM_Deinit                                         **
**                                                                            **
** Service ID           : 0x04                                                **
**                                                                            **
** Description          : De-initializes the BSW Mode Manager.                **
**                                                                            **
** Reentrancy           : Non Reentrant                                       **
**                                                                            **
** Input Parameters     : None                                                **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GblInitStatus                                **
**                                                                            **
**                        Function(s) invoked :                               **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_Deinit(void)
{
  /* Setting BswM_GblInitStatus flag to Unint */
  BswM_GblInitStatus = BSWM_UNINITIALIZED;
}


/*******************************************************************************
** Function Name        : BswM_Init                                           **
**                                                                            **
** Service ID           : 0x00                                                **
**                                                                            **
** Description          : This Service Initializes the BSW Mode Manager       **
**                                                                            **
** Reentrancy           : Non Reentrant                                       **
**                                                                            **
** Input Parameters     : None                                                **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : The Bsw Mode manager must be initialized.           **
**                                                                            **
** Remarks              : Global Variable(s)  :                               **
**                          BswM_GblInitStatus                                **
**                                                                            **
**                        Function(s) invoked :                               **
**                          Det_ReportError                                   **
*******************************************************************************/
FUNC(void, BSWM_CODE) BswM_Init
 (P2CONST(BswM_ConfigType, AUTOMATIC, BSWM_APPL_CONST) ConfigPtr)
{
  /* Definition of local variable */
  uint8 LucId;
  BswM_RuleIdType LddId;
  P2CONST(BswM_RuleIdType, AUTOMATIC, BSWM_CONST) LpRuleId;
  BSWM_UNUSED_PTR(ConfigPtr);
  
  for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_BSW_MODE_NOTIFICATION; LucId++)
  {
    /* Initialize previous evaluation result of a rule */
    LpRuleId = BswM_GaaBswModeNotificationProperty[LucId].pRuleId;
    for (LddId = BSWM_ZERO; LddId < BswM_GaaBswModeNotificationProperty[LucId].ddTotalRules; LddId++)
    {
      BswM_InitializeRulePreviousResult(LpRuleId[LddId]);
    }
    
    #if ((BSWM_MIXED == BSWM_BSW_MODE_NOTIFICATION_INIT_STATUS) || (BSWM_VALID == BSWM_BSW_MODE_NOTIFICATION_INIT_STATUS))
    #if (BSWM_MIXED == BSWM_BSW_MODE_NOTIFICATION_INIT_STATUS)
    if (BSWM_VALID == BswM_GaaBswModeNotificationProperty[LucId].blModeInitValueStatus)
    {
    #endif
      /* Update Current State with configured initial value */
      BswM_GaaBswModeNotification[LucId].ddCurrentMode = BswM_GaaBswModeNotificationProperty[LucId].ddModeInitValue;
      
      /* Update Current State status as VALID */
      BswM_GaaBswModeNotification[LucId].blModeValueStatus = BSWM_VALID;
      
    #if (BSWM_MIXED == BSWM_BSW_MODE_NOTIFICATION_INIT_STATUS)
    }
    else
    #endif
    #endif
    #if (BSWM_MIXED == BSWM_BSW_MODE_NOTIFICATION_INIT_STATUS)
    {
    #endif
      #if ((BSWM_MIXED == BSWM_BSW_MODE_NOTIFICATION_INIT_STATUS) || (BSWM_INVALID == BSWM_BSW_MODE_NOTIFICATION_INIT_STATUS))
      BswM_GaaBswModeNotification[LucId].blModeValueStatus = BSWM_INVALID;
      #endif
    #if (BSWM_MIXED == BSWM_BSW_MODE_NOTIFICATION_INIT_STATUS)
    }
    #endif
  }
  
  for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_COMM_INDICATION; LucId++)
  {
    /* Initialize previous evaluation result of a rule */
    LpRuleId = BswM_GaaComMIndicationProperty[LucId].pRuleId;
    for (LddId = BSWM_ZERO; LddId < BswM_GaaComMIndicationProperty[LucId].ddTotalRules; LddId++)
    {
      BswM_InitializeRulePreviousResult(LpRuleId[LddId]);
    }
    #if ((BSWM_MIXED == BSWM_COMM_INDICATION_INIT_STATUS) || (BSWM_VALID == BSWM_COMM_INDICATION_INIT_STATUS))
    #if (BSWM_MIXED == BSWM_COMM_INDICATION_INIT_STATUS)
    if (BSWM_VALID == BswM_GaaComMIndicationProperty[LucId].blModeInitValueStatus)
    {
    #endif
      /* Update Current State with configured initial value */
      BswM_GaaComMCurrentMode[LucId].ddCurrentMode = BswM_GaaComMIndicationProperty[LucId].ddModeInitValue;
      
      /* Update Current State status as VALID */
      BswM_GaaComMCurrentMode[LucId].blModeValueStatus = BSWM_VALID;
      
    #if (BSWM_MIXED == BSWM_COMM_INDICATION_INIT_STATUS)
    }
    else
    #endif
    #endif
    #if (BSWM_MIXED == BSWM_COMM_INDICATION_INIT_STATUS)
    {
    #endif
      #if ((BSWM_MIXED == BSWM_COMM_INDICATION_INIT_STATUS) || (BSWM_INVALID == BSWM_COMM_INDICATION_INIT_STATUS))
      BswM_GaaComMCurrentMode[LucId].blModeValueStatus = BSWM_INVALID;
      #endif
    #if (BSWM_MIXED == BSWM_COMM_INDICATION_INIT_STATUS)
    }
    #endif
  }
  
  for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_DCM_COM_REQUEST; LucId++)
  {
    /* Initialize previous evaluation result of a rule */
    LpRuleId = BswM_GaaDcmComRequestProperty[LucId].pRuleId;
    for (LddId = BSWM_ZERO; LddId < BswM_GaaDcmComRequestProperty[LucId].ddTotalRules; LddId++)
    {
      BswM_InitializeRulePreviousResult(LpRuleId[LddId]);
    }
    #if ((BSWM_MIXED == BSWM_DCM_COM_REQUEST_INIT_STATUS) || (BSWM_VALID == BSWM_DCM_COM_REQUEST_INIT_STATUS))
    #if (BSWM_MIXED == BSWM_DCM_COM_REQUEST_INIT_STATUS)
    if (BSWM_VALID == BswM_GaaDcmComRequestProperty[LucId].blModeInitValueStatus)
    {
    #endif
      /* Update Current State with configured initial value */
      BswM_GaaDcmReqCommunication[LucId].ddRequestedMode = BswM_GaaDcmComRequestProperty[LucId].ddModeInitValue;
      
      /* Update Current State status as VALID */
      BswM_GaaDcmReqCommunication[LucId].blModeValueStatus = BSWM_VALID;
      
    #if (BSWM_MIXED == BSWM_DCM_COM_REQUEST_INIT_STATUS)
    }
    else
    #endif
    #endif
    #if (BSWM_MIXED == BSWM_DCM_COM_REQUEST_INIT_STATUS)
    {
    #endif
      #if ((BSWM_MIXED == BSWM_DCM_COM_REQUEST_INIT_STATUS) || (BSWM_INVALID == BSWM_DCM_COM_REQUEST_INIT_STATUS))
      BswM_GaaDcmReqCommunication[LucId].blModeValueStatus = BSWM_INVALID;
      #endif
    #if (BSWM_MIXED == BSWM_DCM_COM_REQUEST_INIT_STATUS)
    }
    #endif
  }
  
  for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_ECUM_INDICATION; LucId++)
  {
    /* Initialize previous evaluation result of a rule */
    LpRuleId = BswM_GaaEcuMIndicationProperty[LucId].pRuleId;
    for (LddId = BSWM_ZERO; LddId < BswM_GaaEcuMIndicationProperty[LucId].ddTotalRules; LddId++)
    {
      BswM_InitializeRulePreviousResult(LpRuleId[LddId]);
    }
    #if ((BSWM_MIXED == BSWM_ECUM_INDICATION_INIT_STATUS) || (BSWM_VALID == BSWM_ECUM_INDICATION_INIT_STATUS))
    #if (BSWM_MIXED == BSWM_ECUM_INDICATION_INIT_STATUS)
    if (BSWM_VALID == BswM_GaaEcuMIndicationProperty[LucId].blModeInitValueStatus)
    {
    #endif
      /* Update Current State with configured initial value */
      BswM_GaaEcuMCurrentState[LucId].ddCurrentState = BswM_GaaEcuMIndicationProperty[LucId].ddModeInitValue;
      
      /* Update Current State status as VALID */
      BswM_GaaEcuMCurrentState[LucId].blModeValueStatus = BSWM_VALID;
      
    #if (BSWM_MIXED == BSWM_ECUM_INDICATION_INIT_STATUS)
    }
    else
    #endif
    #endif
    #if (BSWM_MIXED == BSWM_ECUM_INDICATION_INIT_STATUS)
    {
    #endif
      #if ((BSWM_MIXED == BSWM_ECUM_INDICATION_INIT_STATUS) || (BSWM_INVALID == BSWM_ECUM_INDICATION_INIT_STATUS))
      BswM_GaaEcuMCurrentState[LucId].blModeValueStatus = BSWM_INVALID;
      #endif
    #if (BSWM_MIXED == BSWM_ECUM_INDICATION_INIT_STATUS)
    }
    #endif
  }
  
  for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_ECUM_WAKEUP_SOURCE; LucId++)
  {
    /* Initialize previous evaluation result of a rule */
    LpRuleId = BswM_GaaEcuMWakeupIndicationProperty[LucId].pRuleId;
    for (LddId = BSWM_ZERO; LddId < BswM_GaaEcuMWakeupIndicationProperty[LucId].ddTotalRules; LddId++)
    {
      BswM_InitializeRulePreviousResult(LpRuleId[LddId]);
    }
    #if ((BSWM_MIXED == BSWM_ECUM_WAKEUP_SOURCE_INIT_STATUS) || (BSWM_VALID == BSWM_ECUM_WAKEUP_SOURCE_INIT_STATUS))
    #if (BSWM_MIXED == BSWM_ECUM_WAKEUP_SOURCE_INIT_STATUS)
    if (BSWM_VALID == BswM_GaaEcuMWakeupIndicationProperty[LucId].blModeInitValueStatus)
    {
    #endif
      /* Update Current State with configured initial value */
      BswM_GaaEcuMCurrentWakeup[LucId].ddState = BswM_GaaEcuMWakeupIndicationProperty[LucId].ddModeInitValue;
      
      /* Update Current State status as VALID */
      BswM_GaaEcuMCurrentWakeup[LucId].blModeValueStatus = BSWM_VALID;
      
    #if (BSWM_MIXED == BSWM_ECUM_WAKEUP_SOURCE_INIT_STATUS)
    }
    else
    #endif
    #endif
    #if (BSWM_MIXED == BSWM_ECUM_WAKEUP_SOURCE_INIT_STATUS)
    {
    #endif
      #if ((BSWM_MIXED == BSWM_ECUM_WAKEUP_SOURCE_INIT_STATUS) || (BSWM_INVALID == BSWM_ECUM_WAKEUP_SOURCE_INIT_STATUS))
      BswM_GaaEcuMCurrentWakeup[LucId].blModeValueStatus = BSWM_INVALID;
      #endif
    #if (BSWM_MIXED == BSWM_ECUM_WAKEUP_SOURCE_INIT_STATUS)
    }
    #endif
  }
  
  for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_GENERIC_REQUEST; LucId++)
  {
    /* Initialize previous evaluation result of a rule */
    LpRuleId = BswM_GaaGenericRequestProperty[LucId].pRuleId;
    for (LddId = BSWM_ZERO; LddId < BswM_GaaGenericRequestProperty[LucId].ddTotalRules; LddId++)
    {
      BswM_InitializeRulePreviousResult(LpRuleId[LddId]);
    }
    #if ((BSWM_MIXED == BSWM_GENERIC_REQUEST_INIT_STATUS) || (BSWM_VALID == BSWM_GENERIC_REQUEST_INIT_STATUS))
    #if (BSWM_MIXED == BSWM_GENERIC_REQUEST_INIT_STATUS)
    if (BSWM_VALID == BswM_GaaGenericRequestProperty[LucId].blModeInitValueStatus)
    {
    #endif
      /* Update Current State with configured initial value */
      BswM_GaaGenericCurrentState[LucId].ddRequestedState = BswM_GaaGenericRequestProperty[LucId].ddModeInitValue;
      
      /* Update Current State status as VALID */
      BswM_GaaGenericCurrentState[LucId].blModeValueStatus = BSWM_VALID;
      
    #if (BSWM_MIXED == BSWM_GENERIC_REQUEST_INIT_STATUS)
    }
    else
    #endif
    #endif
    #if (BSWM_MIXED == BSWM_GENERIC_REQUEST_INIT_STATUS)
    {
    #endif
      #if ((BSWM_MIXED == BSWM_GENERIC_REQUEST_INIT_STATUS) || (BSWM_INVALID == BSWM_GENERIC_REQUEST_INIT_STATUS))
      BswM_GaaGenericCurrentState[LucId].blModeValueStatus = BSWM_INVALID;
      #endif
    #if (BSWM_MIXED == BSWM_GENERIC_REQUEST_INIT_STATUS)
    }
    #endif
  }
  
  for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_NVM_CURRENT_JOB_MODE; LucId++)
  {
    /* Initialize previous evaluation result of a rule */
    LpRuleId = BswM_GaaNvMJobModeIndicationProperty[LucId].pRuleId;
    for (LddId = BSWM_ZERO; LddId < BswM_GaaNvMJobModeIndicationProperty[LucId].ddTotalRules; LddId++)
    {
      BswM_InitializeRulePreviousResult(LpRuleId[LddId]);
    }
    #if ((BSWM_MIXED == BSWM_NVM_CURRENT_JOB_MODE_INIT_STATUS) || (BSWM_VALID == BSWM_NVM_CURRENT_JOB_MODE_INIT_STATUS))
    #if (BSWM_MIXED == BSWM_NVM_CURRENT_JOB_MODE_INIT_STATUS)
    if (BSWM_VALID == BswM_GaaNvMJobModeIndicationProperty[LucId].blModeInitValueStatus)
    {
    #endif
      /* Update Current State with configured initial value */
      BswM_GaaNvMCurrentJobMode[LucId].ddCurrentJobMode = BswM_GaaNvMJobModeIndicationProperty[LucId].ddModeInitValue;
      
      /* Update Current State status as VALID */
      BswM_GaaNvMCurrentJobMode[LucId].blModeValueStatus = BSWM_VALID;
      
    #if (BSWM_MIXED == BSWM_NVM_CURRENT_JOB_MODE_INIT_STATUS)
    }
    else
    #endif
    #endif
    #if (BSWM_MIXED == BSWM_NVM_CURRENT_JOB_MODE_INIT_STATUS)
    {
    #endif
      #if ((BSWM_MIXED == BSWM_NVM_CURRENT_JOB_MODE_INIT_STATUS) || (BSWM_INVALID == BSWM_NVM_CURRENT_JOB_MODE_INIT_STATUS))
      BswM_GaaNvMCurrentJobMode[LucId].blModeValueStatus = BSWM_INVALID;
      #endif
    #if (BSWM_MIXED == BSWM_NVM_CURRENT_JOB_MODE_INIT_STATUS)
    }
    #endif
  }
  
  for (LucId = BSWM_ZERO; LucId < BSWM_TOTAL_PORTS_OF_SWC_MODE_REQUEST; LucId++)
  {
    /* Initialize previous evaluation result of a rule */
    LpRuleId = BswM_GaaSwcModeRequestProperty[LucId].pRuleId;
    for (LddId = BSWM_ZERO; LddId < BswM_GaaSwcModeRequestProperty[LucId].ddTotalRules; LddId++)
    {
      BswM_InitializeRulePreviousResult(LpRuleId[LddId]);
    }
    
    #if ((BSWM_MIXED == BSWM_SWC_MODE_REQUEST_INIT_STATUS) || (BSWM_VALID == BSWM_SWC_MODE_REQUEST_INIT_STATUS))
    #if (BSWM_MIXED == BSWM_SWC_MODE_REQUEST_INIT_STATUS)
    if (BSWM_VALID == BswM_GaaSwcModeRequestProperty[LucId].blModeInitValueStatus)
    {
    #endif
      /* Update Current State with configured initial value */
      BswM_GaaSwcModeRequest[LucId].ddRequestedMode = BswM_GaaSwcModeRequestProperty[LucId].ddModeInitValue;
      
      /* Update Current State status as VALID */
      BswM_GaaSwcModeRequest[LucId].blModeValueStatus = BSWM_VALID;
      
    #if (BSWM_MIXED == BSWM_SWC_MODE_REQUEST_INIT_STATUS)
    }
    else
    #endif
    #endif
    #if (BSWM_MIXED == BSWM_SWC_MODE_REQUEST_INIT_STATUS)
    {
    #endif
      #if ((BSWM_MIXED == BSWM_SWC_MODE_REQUEST_INIT_STATUS) || (BSWM_INVALID == BSWM_SWC_MODE_REQUEST_INIT_STATUS))
      BswM_GaaSwcModeRequest[LucId].blModeValueStatus = BSWM_INVALID;
      #endif
    #if (BSWM_MIXED == BSWM_SWC_MODE_REQUEST_INIT_STATUS)
    }
    #endif
  }
  
  /* Set the variable BswM_GblInitStatus to indicate BswM is initialized */
  BswM_GblInitStatus = BSWM_INITIALIZED;
}



#define BSWM_STOP_SEC_CODE
#include "MemMap.h"
/*******************************************************************************
**                      End of File                                           **
*******************************************************************************/
