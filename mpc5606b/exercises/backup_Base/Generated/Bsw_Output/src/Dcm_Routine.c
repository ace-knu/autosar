/*******************************************************************************
**  FILE-NAME: Dcm_Routine.c                                                  **
**                                                                            **
**  MODULE-NAME: AUTOSAR DCM Module                                           **
**                                                                            **
**  NOTE: This file is auto generated, do not edit this file manually.        **
**                                                                            **
*******************************************************************************/

/*******************************************************************************
**                      Generation Tool Information                           **
*******************************************************************************/

/*
 * INPUT FILE:    Configuration\ECU\Ecud_ComM.arxml
 *                Configuration\ECU\Ecud_Dcm.arxml
 *                Configuration\ECU\Ecud_NvM.arxml
 *                Configuration\ECU\Ecud_PduR.arxml
 * GENERATED ON:  This timestamp is removed.
 */


/*******************************************************************************
**                      Header File Inclusion                                 **
*******************************************************************************/
#include "Dcm.h"
#include "Dcm_PCTypes.h"
#include "Dcm_Routine.h"
#include "Dcm_Ram.h"
#include "Dcm_DspMain.h"
#include "Rte_Dcm.h"
#include "SchM_Dcm.h"
#include "Dcm_DspServices.h"
#include "Dcm_PackUnPack.h"
#include "Dcm_DsdInternal.h"
#include "Dcm_DslInternal.h"
#if(DCM_OBD_REQ_CTLRL_ONBOADSYSTEM_SERVICE == STD_ON)
#include "Dcm_DspOBDInternals.h"
#include "Dcm_DspOBDServices.h"
#endif
#include "Dcm_Config.h"

/*******************************************************************************
**                      Static Function Declarations                          **
*******************************************************************************/
#if(DCM_ROUTINECONTROL_SERVICE == STD_ON)
#define DCM_START_SEC_CODE
#include "MemMap.h"
static FUNC(Std_ReturnType, DCM_CODE) Dcm_Internal_DcmRoutineControl(
uint16 LusRoutineIdentifier, uint16 LusRIDIndex,
P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext);
#define DCM_STOP_SEC_CODE
#include "MemMap.h"
#endif

/*******************************************************************************
**                      Global Variables                                      **
*******************************************************************************/

/*******************************************************************************
**                      Function Definitions                                  **
*******************************************************************************/

/* polyspace:begin<RTE: NIV : Not a defect : No Action Planned > initialized variable */
/* polyspace:begin<RTE: NIP : Not a defect : No Action Planned > pointer is not null */
/* polyspace:begin<RTE: IDP : Not a defect : No Action Planned > address pointed to function is correct */
/* polyspace:begin<RTE: COR : Not a defect : No Action Planned > function ptr points to a valid function */
/* polyspace:begin<MISRA-C:8.10:Not a defect:Justify with annotations> Whether the Dcm api function is required internal or external linkage, depends on user configuration */
/* polyspace:begin<MISRA-C:13.7:Not a defect:Justify with annotations> It has not any impact. */

#if(DCM_ROUTINECONTROL_SERVICE == STD_ON)
#define DCM_START_SEC_CODE
#include "MemMap.h"
static FUNC(Std_ReturnType, DCM_CODE) Dcm_Internal_DcmRoutineControl(
uint16 LusRoutineIdentifier, uint16 LusRIDIndex,
P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
{
  P2VAR(Dcm_RoutineConfigType, AUTOMATIC, DCM_APPL_CONST)LpRIDTAB;
  P2CONST(Dcm_RoutineSignalInfoType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineSignalInfo;
  uint8 LucSubFunction;
  Std_ReturnType LddReturnValue = E_NOT_OK;

  LucSubFunction = pMsgContext->reqData[DCM_ZERO] & DCM_SUBFUNCTION_MASK;
  LpRIDTAB = &Dcm_GaaRoutineControlConfig[LusRIDIndex];
  LpRoutineSignalInfo = LpRIDTAB->pRoutineSignalInfo;
  LddReturnValue = Dcm_RoutineSignalFunction(LucSubFunction, LusRoutineIdentifier);

  if((LddReturnValue == E_OK) && (NULL_PTR != LpRoutineSignalInfo))
  {
    if(LucSubFunction == DCM_ROUTINE_CTRL_START)
    {
      /* Change the Flag to 0x0F */
      LpRIDTAB->ucStartStopRIDFlag = DCM_ROUTINE_START_MASK;
      #if(DCM_ROUTINE_START_OUTSIGNAL_CONFIGURED == STD_ON)
      /* Check whether routine has startOut signal or not */
      if(LpRoutineSignalInfo->ucNumOfStartRtnOutSignal > DCM_ZERO)
      {
        (void)Dcm_StartRoutinePackSignal(LusRIDIndex, pMsgContext);
      }
      #endif
    }
    else if(LucSubFunction == DCM_ROUTINE_CTRL_STOP)
    {
      /* Change the Flag to 0xFF */
      LpRIDTAB->ucStartStopRIDFlag = DCM_ROUTINE_STOP_MASK;
      #if(DCM_ROUTINE_STOP_OUTSIGNAL_CONFIGURED == STD_ON)
      /* Check whether routine has stopOut signal or not */
      if(LpRoutineSignalInfo->ucNumOfStopRtnOutSignal > DCM_ZERO)
      {
        (void)Dcm_StopRoutinePackSignal(LusRIDIndex, pMsgContext);
      }
      #endif
    }
    #if(DCM_ROUTINE_REQUEST_OUTSIGNAL_CONFIGURED == STD_ON)
    else if(LucSubFunction == DCM_ROUTINE_CTRL_REQUEST_RESULT)
    {
      /* Check whether routine has requestResultOut signal or not */
      if(LpRoutineSignalInfo->ucNumOfRtnRequestResOutSignal > DCM_ZERO)
      {
        (void)Dcm_RequestResultRoutinePackSignal(LusRoutineIdentifier, LusRIDIndex, pMsgContext);
      }
    }
    #endif
    else
    {
      /* To avoid QAC warning */
    }
  }
  
  return(LddReturnValue);
}

/*******************************************************************************
** Function Name        : Dcm_DcmRoutineControl                               **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : The Routine Control service is used to              **
**                        enable different diagnostic sessions in the server. **
**                        A diagnostic session enables a specific set of      **
**                        diagnostic services and/or functionality in the     **
**                        server                                              **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : Dcm_DsdProcessingDone          **
*******************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DcmRoutineControl(Dcm_OpStatusType OpStatus,
P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
{
  P2CONST(Dcm_SubServiceIdConfigType, AUTOMATIC, DCM_APPL_CONST) subServiceCfg;
  Std_ReturnType requestResult = E_NOT_OK;

  subServiceCfg = Dcm_DsdInternal_GetSubFunctionByMsgContext(pMsgContext);
  
  if(NULL_PTR == subServiceCfg)
  { 
    /* Never be reached, but this code is added for MISRA-rules */  
    Dcm_InternalSetNegResponse(pMsgContext, DCM_E_GENERALREJECT);
    Dcm_InternalProcessingDone(pMsgContext, DCM_SYNC_DONE);
  }
  /* External diagnostic subservice processing  */
  else if(NULL_PTR != subServiceCfg->pSubServiceFnc)
  {
    if ( (DCM_INITIAL == OpStatus) && (pMsgContext->reqDataLen > 0U))
    {
      /* @SWS_Dcm_00764 The pointer in pMsgContext shall point behind the SubFunction */  
      pMsgContext->reqData = &pMsgContext->reqData[1U];
      pMsgContext->reqDataLen--;
    }
    requestResult = subServiceCfg->pSubServiceFnc(OpStatus, pMsgContext);
  }
  /* Dcm-Internal diagnostic subservice processing  */  
  else
  {
    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpReqResData;
    P2CONST(Dcm_RoutineConfigType, AUTOMATIC, DCM_APPL_CONST)LpRIDTAB;  
    P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpResData;
    #if(DCM_DSP_MODE_RULE_NRC  ==  STD_ON)
    P2CONST(Dcm_ModeRuleConfigType,  AUTOMATIC,  DCM_APPL_CONST) LpModeRule;
    #endif
    uint16 LusRoutineIdentifier;
    uint16 LusRIDIndex = (uint16)0x00;
    uint8 LucSubFunction;
    boolean LblSearchResult;
    Std_ReturnType LddReturnValue = E_NOT_OK;
    
    Dcm_GddNegRespError =  DCM_E_POSITIVERESPONSE;
    
    /* Get the pointer to the request data buffer of pMsgContext */
    LpReqResData = pMsgContext->reqData;
    
    LusRoutineIdentifier = ((uint16)((uint16)LpReqResData[DCM_ONE] << DCM_EIGHT)) | (uint16)LpReqResData[DCM_TWO];
    /* Check if the RID from the request is supported and used */
    LblSearchResult = Dcm_IDSearch(DCM_GET_RID, LusRoutineIdentifier, &LusRIDIndex);
    if(LblSearchResult == DCM_TRUE)
    {
    
      /* Initialize pointer to the parameters of requested RID */
      LpRIDTAB = &Dcm_GaaRoutineControlConfig[LusRIDIndex];
      
      /* Check for the validity of length */
      if(pMsgContext->reqDataLen < DCM_THREE)
      {
        /* Report the incorrect message length NRC */
        Dcm_GddNegRespError = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
      }
      else if(LpRIDTAB->blRoutineUsed == DCM_FALSE)
      {
        /* Report the Corresponding Routine is used or not */
        Dcm_GddNegRespError = DCM_E_REQUESTOUTOFRANGE;
      }
      else
      {
        if(LpRIDTAB->pRoutineSession != NULL_PTR)
        {
         /* Invoke function to validate Routine session */
         LblSearchResult = Dcm_DsdValidateSession(LpRIDTAB->pRoutineSession, LpRIDTAB->ucSessionCount);
        }
        else
        {
          LblSearchResult = DCM_TRUE;
        }
     
        /* Check is the current session level supported by the service Id */
        if(LblSearchResult == DCM_TRUE)
        {  
          if(LpRIDTAB->pRoutineSecurity != NULL_PTR)
          {
            LblSearchResult = Dcm_DsdValidateSecurity(LpRIDTAB->pRoutineSecurity, LpRIDTAB->ucSecurityCount);
          } 
          else
          {
            LblSearchResult = DCM_TRUE;
          }
          
          /* Check the current security level supported by the service Id */
          if(LblSearchResult == DCM_TRUE)
          {
            #if(DCM_MODE_RULE  ==  STD_ON)
            if(LpRIDTAB->blModeRuleConfigured == DCM_TRUE)
            {
              LblSearchResult  =  Dcm_DsdModeRuleCheck(LpRIDTAB->ucDIDmoderuleArrayindex);
            }
            if(LblSearchResult  !=  DCM_TRUE)
            {
              #if(DCM_DSP_MODE_RULE_NRC == STD_ON)
              LpModeRule  =   &Dcm_GaaModeRuleConfig[LpRIDTAB->ucDIDmoderuleArrayindex];              
              Dcm_GddNegRespError  =  LpModeRule->ucNRCType;
              #else
              Dcm_GddNegRespError  =  DCM_E_CONDITIONSNOTCORRECT;
              #endif
            }
            else
            #endif 
            {

              if((LusRoutineIdentifier >= (uint16)0xE000) &&
              (LusRoutineIdentifier <= (uint16)0xE0FF))
              {
                #if(DCM_OBD_REQ_CTLRL_ONBOADSYSTEM_SERVICE == STD_ON)
                Dcm_DspHandleOBDRoutineControl(pMsgContext);
                #else
                /* Report the Request out of range NRC */
                Dcm_GddNegRespError = DCM_E_REQUESTOUTOFRANGE;  
                #endif
              }
              else
              {
                /* Initialize Response buffer to local pointer */
                LpResData = pMsgContext->resData;
                /* Update sub function value */
                LucSubFunction = LpReqResData[DCM_ZERO] & DCM_SUBFUNCTION_MASK;        
                /* Update sub function number */
                LpResData[DCM_ZERO] = LucSubFunction;
                /* Update First Byte RID */
                LpResData[DCM_ONE] = LpReqResData[DCM_ONE];
                /* Update Second Byte RID */
                LpResData[DCM_TWO] = LpReqResData[DCM_TWO];
                /* Invoke Routine Control,  LucSubFunction =1 for Start, 2 for Stop, 3 for request result */
                if(LucSubFunction == DCM_ROUTINE_CTRL_START)
                {
                  LddReturnValue = Dcm_StartRoutineUnPackSignal(LusRoutineIdentifier, LusRIDIndex, pMsgContext);

                  if(LddReturnValue == E_OK)
                  {
                    LddReturnValue = Dcm_Internal_DcmRoutineControl(LusRoutineIdentifier, LusRIDIndex, pMsgContext);
                  }
                }
                else if((LucSubFunction == DCM_ROUTINE_CTRL_STOP) && (LpRIDTAB->blStopRoutineSupported == DCM_TRUE))
                {
                  LddReturnValue = Dcm_StopRoutineUnPackSignal(LusRoutineIdentifier, LusRIDIndex, pMsgContext);

                  if(LddReturnValue == E_OK)
                  {
                    LddReturnValue = Dcm_Internal_DcmRoutineControl(LusRoutineIdentifier, LusRIDIndex, pMsgContext);
                  }
                }
                else if((LucSubFunction == DCM_ROUTINE_CTRL_REQUEST_RESULT) && (LpRIDTAB->blRequestResultSupported == DCM_TRUE))
                {
                  LddReturnValue = Dcm_RequestResultRoutinePackSignal(LusRoutineIdentifier, LusRIDIndex, pMsgContext); 
                }
                else
                {
                  /* Report the Subfunction not supported NRC */
                  Dcm_GddNegRespError = DCM_E_SUBFUNCTIONNOTSUPPORTED;
                }
              }
            }
          }
          else
          {
             /* Report the Security Access Denied NRC */
            Dcm_GddNegRespError = DCM_E_SECURITYACCESSDENIED;
          }  
        }
        else
        {
          /* Report the Request out of range NRC */
          Dcm_GddNegRespError = DCM_E_REQUESTOUTOFRANGE;
        }      
      }
    }
    else
    {
      /* Report the Request out of range NRC */
      Dcm_GddNegRespError = DCM_E_REQUESTOUTOFRANGE;
    }
    Dcm_RoutineHandleResponse((uint8)LddReturnValue, LusRIDIndex);
  } 

  return requestResult;
}

/*******************************************************************************
** Function Name        : Dcm_StartRoutineUnPackSignal                        **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This function unpacks the signal value from the     **
**                        routine control option record passed in the start   **
**                        routine request and invokes the corresponding start **
**                        API and invokes the function to pack the output     **
**                        signal value.                                       **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : Dcm_GblProtocolEndianess       **
**                                                                            **
*******************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_StartRoutineUnPackSignal(
uint16 LusRoutineIdentifier, uint16 LusRIDIndex,
P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
{
  P2VAR(Dcm_RoutineConfigType, AUTOMATIC, DCM_VAR)LpRIDTAB;
  Std_ReturnType LddReturnValue;
 
  #if(DCM_ROUTINE_START_INSIGNAL_CONFIGURED == STD_ON)
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpRequestData;
  uint32 LulTotalSignalLength;
  uint16 LusNumOfSignals;
  uint16 LusSignalCount;
  uint8 LucByteCount;
  uint8 LucSignalType;
  Dcm_PackUnpackSignalData LddUnPackSignal;
  P2CONST(Dcm_StartRoutineInSignalType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineInSignalInfo;
  #endif

  #if((DCM_ROUTINE_START_INSIGNAL_CONFIGURED == STD_ON) || \
  (DCM_ROUTINE_START_OUTSIGNAL_CONFIGURED == STD_ON))
  P2CONST(Dcm_RoutineSignalInfoType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineSignalInfo;
  #endif
  LpRIDTAB = &Dcm_GaaRoutineControlConfig[LusRIDIndex];
  #if((DCM_ROUTINE_START_INSIGNAL_CONFIGURED == STD_ON) || \
  (DCM_ROUTINE_START_OUTSIGNAL_CONFIGURED == STD_ON))
  LpRoutineSignalInfo = LpRIDTAB->pRoutineSignalInfo;
  #endif

  LddReturnValue = E_NOT_OK;
  Dcm_GddOpStatus = DCM_INITIAL;

  #if(DCM_ROUTINE_START_INSIGNAL_CONFIGURED == STD_ON)
  if(NULL_PTR == LpRoutineSignalInfo)
  {
    /* Never be reached here */
    Dcm_GddNegRespError = DCM_E_CONDITIONSNOTCORRECT;
  }
  else if((LpRoutineSignalInfo->ucNumOfStartRtnInSignal > DCM_ZERO) &&
       (NULL_PTR != LpRoutineSignalInfo->pStartRoutineIn))
  {
    /* Initialize pointer to the Start Routine In Signal */
    LpRoutineInSignalInfo = LpRoutineSignalInfo->pStartRoutineIn;
    LulTotalSignalLength = DCM_ZERO;
    
    /* Count the number of Start Routine In Signal */
    LusNumOfSignals = LpRoutineSignalInfo->ucNumOfStartRtnInSignal;  
    
    for(LusSignalCount = 0; LusSignalCount < LusNumOfSignals; LusSignalCount++)
    {
      LucSignalType = LpRoutineInSignalInfo[LusSignalCount].ucSignalType;
          
      if((LpRIDTAB->blRoutineFixedLength == FALSE) &&
      ((LusSignalCount + DCM_ONE) == LusNumOfSignals) &&
      (LucSignalType == DCM_FIVE))
      {
        LulTotalSignalLength += LpRoutineInSignalInfo[LusSignalCount].ulSignalLength;
  
        if(pMsgContext->reqDataLen > (LulTotalSignalLength + DCM_THREE))
        {
          /* Report the incorrect message length NRC */
          Dcm_GddNegRespError = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
        }
      }
      else if((LusSignalCount + DCM_ONE) == LusNumOfSignals)
      {
        LulTotalSignalLength += LpRoutineInSignalInfo[LusSignalCount].ucSignalSize;
  
        if(pMsgContext->reqDataLen != (LulTotalSignalLength + DCM_THREE))
        {
          /* Report the incorrect message length NRC */
          Dcm_GddNegRespError = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
        }
      }
      else
      {
        LulTotalSignalLength += LpRoutineInSignalInfo[LusSignalCount].ucSignalSize;
      }
    }

    if(Dcm_GddNegRespError == DCM_E_POSITIVERESPONSE)
    {
      LddUnPackSignal.ulSignalLength = (uint32)0x00;
      LddUnPackSignal.ucShiftBits = (uint8)0x00;
      LddUnPackSignal.ucStartMask = (uint8)0x00;
      LddUnPackSignal.ucEndMask = (uint8)0x00;
      LddUnPackSignal.ucSignalType = (uint8)0x00;
      LddUnPackSignal.ucSignalTypeorSize = (uint8)0x00;
      LddUnPackSignal.ucSignalSize = (uint8)0x00;
      LddUnPackSignal.ucSignMask = (uint8)0x00;
     
      LucByteCount = DCM_ZERO;
      for(LusSignalCount = 0; LusSignalCount < LusNumOfSignals; LusSignalCount++)
      {
        /* Initialize Global pointer to the RoutineSignalInData */
        Dcm_GpRoutineSignalInDataPtr = &Dcm_GaaRoutineSignalInData[LucByteCount];
      
        /* Fetching the values of ucNoOfShiftBits, ucStartMask from generation 
        tool */
        LucSignalType = LpRoutineInSignalInfo[LusSignalCount].ucSignalType;
        LddUnPackSignal.ucShiftBits = LpRoutineInSignalInfo[LusSignalCount].ucNoOfShiftBits;
        LddUnPackSignal.ucEndMask = LpRoutineInSignalInfo[LusSignalCount].ucEndMask;
        LddUnPackSignal.ucSignalType = LucSignalType;
        LddUnPackSignal.ucSignMask = LpRoutineInSignalInfo[LusSignalCount].ucSignMask;
        
        if((LpRIDTAB->blRoutineFixedLength == FALSE) && 
        ((LusSignalCount + DCM_ONE) == LusNumOfSignals) &&
        (LucSignalType == DCM_FIVE))
        {  
          uint8 minNumOfReq = DCM_THREE + LpRoutineInSignalInfo[LusSignalCount].ucSignalStartByte;
          LddUnPackSignal.ulSignalLength = (uint32)pMsgContext->reqDataLen - (uint32)minNumOfReq;
          Dcm_GusCurrentDataLength = (uint16)LddUnPackSignal.ulSignalLength;
        }
        else
        {
          LddUnPackSignal.ucSignalSize = LpRoutineInSignalInfo[LusSignalCount].ucSignalSize;
        }    
        
        LpRequestData = &pMsgContext->reqData[DCM_THREE + 
        (LpRoutineInSignalInfo[LusSignalCount].ucSignalStartByte)];
        
        /* Call the function Unpack Function */
        if(LpRoutineInSignalInfo[LusSignalCount].ucRdFuncIndex < Dcm_Num_Of_SigRdFuncPtr)
        {
          Dcm_GaaSigRdFuncPtr[LpRoutineInSignalInfo[LusSignalCount].ucRdFuncIndex].pRdFuncPtr
          (LddUnPackSignal, LpRequestData, 
            (P2VAR(void, AUTOMATIC, DCM_APPL_DATA))Dcm_GpRoutineSignalInDataPtr);
        }
        
        LucByteCount += LucSignalType;
      }
    }
  }
  /* Check if the request length is three, if no RoutineInSignal is configured */
  else
  #endif    
  {
    if(pMsgContext->reqDataLen != DCM_THREE)
    {
      /* Report the incorrect message length NRC */
      Dcm_GddNegRespError = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
    else
    {
      /* Do Nothing */
    }
  }
  
  if(Dcm_GddNegRespError == DCM_E_POSITIVERESPONSE)
  {
    /* Update return value */
    LddReturnValue = E_OK;
  }

  return(LddReturnValue);
}

/*******************************************************************************
** Function Name        : Dcm_StopRoutineUnPackSignal                         **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This function unpacks the signal value from the     **
**                        routine control option record passed in the stop    **
**                        routine request and invokes the corresponding start **
**                        API and invokes the function to pack the output     **
**                        signal value.                                       **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : Dcm_GblProtocolEndianess       **
**                                                                            **
*******************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_StopRoutineUnPackSignal(
uint16 LusRoutineIdentifier, uint16 LusRIDIndex, 
P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
{
  P2VAR(Dcm_RoutineConfigType, AUTOMATIC, DCM_VAR)LpRIDTAB;
  Std_ReturnType LddReturnValue;

  #if(DCM_ROUTINE_STOP_INSIGNAL_CONFIGURED == STD_ON)
  uint32 LulTotalSignalLength;
  uint16 LusNumOfSignals;
  uint16 LusSignalCount;
  uint8 LucByteCount;
  uint8 LucSignalType;
  Dcm_PackUnpackSignalData LddUnPackSignal;
  P2CONST(Dcm_StopRoutineInSignalType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineInSignalInfo;
  #endif

  #if((DCM_ROUTINE_STOP_INSIGNAL_CONFIGURED == STD_ON) || \
  (DCM_ROUTINE_STOP_OUTSIGNAL_CONFIGURED == STD_ON))
  P2CONST(Dcm_RoutineSignalInfoType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineSignalInfo;
  #endif
  LpRIDTAB = &Dcm_GaaRoutineControlConfig[LusRIDIndex];
  #if((DCM_ROUTINE_STOP_INSIGNAL_CONFIGURED == STD_ON) || \
  (DCM_ROUTINE_STOP_OUTSIGNAL_CONFIGURED == STD_ON))
  LpRoutineSignalInfo = LpRIDTAB->pRoutineSignalInfo;
  #endif

  LddReturnValue = E_NOT_OK;
  Dcm_GddOpStatus = DCM_INITIAL;

  #if(DCM_ROUTINE_STOP_INSIGNAL_CONFIGURED == STD_ON)
  LulTotalSignalLength = DCM_ZERO;

  if(NULL_PTR == LpRoutineSignalInfo)
  {
    Dcm_GddNegRespError = DCM_E_CONDITIONSNOTCORRECT;
  }
  else if((LpRoutineSignalInfo->ucNumOfStopRtnInSignal != DCM_ZERO) && 
     (NULL_PTR != LpRoutineSignalInfo->pStopRoutineIn))
  {
    /* Initialize pointer to the stop Routine In Signal */
    LpRoutineInSignalInfo = LpRoutineSignalInfo->pStopRoutineIn;
    
    /* Count the number of Start Routine In Signal */
    LusNumOfSignals = LpRoutineSignalInfo->ucNumOfStopRtnInSignal;
    for(LusSignalCount = 0; LusSignalCount < LusNumOfSignals; LusSignalCount++)
    {
      LucSignalType = LpRoutineInSignalInfo[LusSignalCount].ucSignalType;
   
      if((LpRIDTAB->blRoutineFixedLength == FALSE) &&
      ((LusSignalCount + DCM_ONE) == LusNumOfSignals) &&
      (LucSignalType == DCM_FIVE))
      {
        LulTotalSignalLength += LpRoutineInSignalInfo[LusSignalCount].ulSignalLength;

        if(pMsgContext->reqDataLen > (LulTotalSignalLength + DCM_THREE))
        {
             /* Report the incorrect message length NRC */
             Dcm_GddNegRespError = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
        }
      }
      else if((LusSignalCount + DCM_ONE) == LusNumOfSignals)
      {
        LulTotalSignalLength += LpRoutineInSignalInfo[LusSignalCount].ucSignalSize;
          
        if(pMsgContext->reqDataLen != (LulTotalSignalLength + DCM_THREE))
        {
          /* Report the incorrect message length NRC */
          Dcm_GddNegRespError = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
        }
      }
      else
      {
        LulTotalSignalLength += LpRoutineInSignalInfo[LusSignalCount].ucSignalSize;
      }
    }

    /* Check whether no NRC is reported */
    if(Dcm_GddNegRespError == DCM_E_POSITIVERESPONSE)
    {
      /* Check if the request for start routine is requested prior to stop routine request */
      if(LpRIDTAB->ucStartStopRIDFlag == DCM_ROUTINE_START_MASK)
      {  
        /* Initialize pointer to the stop Routine In Signal */
        LpRoutineInSignalInfo = LpRoutineSignalInfo->pStopRoutineIn;
          
        LusNumOfSignals = LpRoutineSignalInfo->ucNumOfStopRtnInSignal;
          
        LucByteCount = DCM_ZERO;
               
        for(LusSignalCount = 0; LusSignalCount < LusNumOfSignals;
        LusSignalCount++)
        {                   
          Dcm_GpRoutineSignalInDataPtr = (P2VAR(void, AUTOMATIC, DCM_APPL_DATA)) & Dcm_GaaRoutineSignalInData[LucByteCount];
               
          LucSignalType = LpRoutineInSignalInfo->ucSignalType;
          LddUnPackSignal.ucShiftBits = LpRoutineInSignalInfo->ucNoOfShiftBits;
          LddUnPackSignal.ucEndMask = LpRoutineInSignalInfo->ucEndMask;
          LddUnPackSignal.ucSignalType = LucSignalType;  
               
          if((LpRIDTAB->blRoutineFixedLength == FALSE) &&
          ((LusSignalCount + DCM_ONE) == LusNumOfSignals) &&
          (LucSignalType == DCM_FIVE))
          {
            uint8 minNumOfReq = DCM_THREE + LpRoutineInSignalInfo->ucSignalStartByte;
            LddUnPackSignal.ulSignalLength = (uint32)pMsgContext->reqDataLen - (uint32)minNumOfReq;
            
            Dcm_GusCurrentDataLength = (uint16)LddUnPackSignal.ulSignalLength;
          }
          else
          {
            LddUnPackSignal.ucSignalSize = LpRoutineInSignalInfo->ucSignalSize;
          }
        }
      }
      else
      {
        Dcm_GddNegRespError = DCM_E_REQUESTSEQUENCEERROR;
      }
    }
  }
  else
  #endif
  {
    if(pMsgContext->reqDataLen != DCM_THREE)
    {
      /* Report the incorrect message length NRC */
      Dcm_GddNegRespError = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
    else if(LpRIDTAB->ucStartStopRIDFlag != DCM_ROUTINE_START_MASK)
    {
      /* Report the incorrect sequence NRC */
      Dcm_GddNegRespError = DCM_E_REQUESTSEQUENCEERROR;
    }
    else
    {
      /* Do nothing */
    }
  }
  
  if(Dcm_GddNegRespError == DCM_E_POSITIVERESPONSE)
  {
    /* Update return value */
    LddReturnValue = E_OK;
  }

  return(LddReturnValue);
}  
    
/*******************************************************************************
** Function Name        : Dcm_RequestResultRoutinePackSignal                  **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This function invokes the corresponding request     **
**                        result API and also packs the output signal value   **
**                        in routine status record  of request result routine **
**                        response.                                           **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : Dcm_GblProtocolEndianess       **
**                                                                            **
*******************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_RequestResultRoutinePackSignal(
uint16 LusRoutineIdentifier, uint16 LusRIDIndex, 
P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
{
  P2VAR(Dcm_RoutineConfigType, AUTOMATIC, DCM_VAR)LpRIDTAB;
  Std_ReturnType LddReturnValue;

  #if(DCM_ROUTINE_REQUEST_OUTSIGNAL_CONFIGURED == STD_ON)
  P2CONST(Dcm_RequestResOutSignalType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineOutSignalInfo;
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpResponseData;
  uint8 LucUint8ByteCount;
  uint8 LucUint16ByteCount;
  uint8 LucUint32ByteCount;
  uint16 LusNumOfSignals;
  uint16 LusSignalCount;
  uint8 LucSignalType;
  Dcm_PackUnpackSignalData LddPackSignal;
  P2CONST(Dcm_RoutineSignalInfoType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineSignalInfo;

  LucUint8ByteCount = DCM_ZERO;
  LucUint16ByteCount = DCM_ZERO;
  LucUint32ByteCount = DCM_ZERO;
  #endif

  LpRIDTAB = &Dcm_GaaRoutineControlConfig[LusRIDIndex];
  Dcm_GddOpStatus = DCM_INITIAL;
  LddReturnValue = E_NOT_OK; 

  if(pMsgContext->reqDataLen != DCM_THREE)
  {
    /* Report the incorrect message length NRC */
    Dcm_GddNegRespError = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  else
  {
    if((LpRIDTAB->ucStartStopRIDFlag == DCM_ROUTINE_STOP_MASK) || 
       (LpRIDTAB->ucStartStopRIDFlag == DCM_ROUTINE_START_MASK))
    {  
      if(Dcm_ServicePendingStatus.ucRoutineReqFunc == DCM_FALSE)
      {
        LddReturnValue = Dcm_RoutineSignalFunction(DCM_ROUTINE_CTRL_REQUEST_RESULT,
          LusRoutineIdentifier);
        Dcm_ServicePendingStatus.ucRoutineReqFunc = DCM_TRUE;

        if((LpRIDTAB->blStopRoutineSupported == DCM_TRUE) && 
           (LpRIDTAB->ucStartStopRIDFlag == DCM_ROUTINE_STOP_MASK))
        {
          LpRIDTAB->ucStartStopRIDFlag = DCM_ZERO;
        }
      }
      
      #if(DCM_ROUTINE_REQUEST_OUTSIGNAL_CONFIGURED == STD_ON)
      LpRoutineSignalInfo = LpRIDTAB->pRoutineSignalInfo;

      if(NULL_PTR != LpRoutineSignalInfo)
      {
        if((LddReturnValue == E_OK) && 
           (LpRoutineSignalInfo->ucNumOfRtnRequestResOutSignal > DCM_ZERO) &&
           (NULL_PTR != LpRoutineSignalInfo->pRequestResOut))
        {
          LddPackSignal.ulSignalLength = (uint32)0x00;
          LddPackSignal.ucShiftBits = (uint8)0x00;
          LddPackSignal.ucStartMask = (uint8)0x00;
          LddPackSignal.ucEndMask = (uint8)0x00;
          LddPackSignal.ucSignalType = (uint8)0x00;
          LddPackSignal.ucSignalTypeorSize = (uint8)0x00;
          LddPackSignal.ucSignalSize = (uint8)0x00;
          LddPackSignal.ucSignMask = (uint8)0x00;
  
          LpRoutineOutSignalInfo = LpRoutineSignalInfo->pRequestResOut;
   
          LusNumOfSignals = LpRoutineSignalInfo->ucNumOfRtnRequestResOutSignal;
  
          for(LusSignalCount = 0; LusSignalCount < LusNumOfSignals; 
              LusSignalCount++)
          {    
            LucSignalType = 
              ((LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize >> DCM_FOUR) & DCM_SIG_BYTE_MASK_VALUE);  
  
            if((LucSignalType == DCM_ONE) || 
               (LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize == 0x50))
            {  
              Dcm_GpRoutineSignalOutDataPtr = &Dcm_GaaRoutineSignalOutData[LucUint8ByteCount];
              LucUint8ByteCount++;
            }
            else if(LucSignalType == DCM_TWO)  
            {
              Dcm_GpRoutineSignalOutDataPtr = &Dcm_GaaRoutineSignalOutData16[LucUint16ByteCount];  
              LucUint16ByteCount++;
            }
            else if(LucSignalType == DCM_FOUR)  
            {
              Dcm_GpRoutineSignalOutDataPtr = &Dcm_GaaRoutineSignalOutData32[LucUint32ByteCount];
              LucUint32ByteCount++;
            }
            else
            {
              /* To avoid QAC warning */
            }          
            LddPackSignal.ucShiftBits = 
            LpRoutineOutSignalInfo[LusSignalCount].ucNoOfShiftBits;
            LddPackSignal.ucStartMask = LpRoutineOutSignalInfo[LusSignalCount].ucStartMask;
            LddPackSignal.ucEndMask = LpRoutineOutSignalInfo[LusSignalCount].ucEndMask;
            LddPackSignal.ucSignalType = LucSignalType;   
                  
            if((LpRIDTAB->blRoutineFixedLength == FALSE) &&
            ((LusSignalCount + DCM_ONE) == LusNumOfSignals) && 
            (LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize == 0x50))
            {  
              LddPackSignal.ulSignalLength  = Dcm_GusCurrentDataLength;
              Dcm_GusLastSignalLength = (uint16) LpRoutineOutSignalInfo[LusSignalCount].ulSignalLength;
              Dcm_DspServiceProcessingSts.RoutineVariableLength = DCM_TRUE;
            }
            else
            {          
              LddPackSignal.ucSignalTypeorSize = 
              LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize;
              Dcm_GusLastSignalLength = DCM_ZERO;
              Dcm_DspServiceProcessingSts.RoutineVariableLength = DCM_FALSE;
            }  
            
            LpResponseData = &pMsgContext->resData[DCM_THREE + 
            (LpRoutineOutSignalInfo[LusSignalCount].ucSignalStartByte)];
  
            if(LpRoutineOutSignalInfo[LusSignalCount].ucWrFuncIndex < Dcm_Num_Of_SigWrFuncPtr)
            {
              Dcm_GaaSigWrFuncPtr[LpRoutineOutSignalInfo[LusSignalCount].ucWrFuncIndex].pWrFuncPtr
              (LddPackSignal, LpResponseData, 
                (P2VAR(void, AUTOMATIC, DCM_APPL_DATA))Dcm_GpRoutineSignalOutDataPtr);
            }
          }
        }
      }
      #endif
    }
    else
    {
      Dcm_GddNegRespError = DCM_E_REQUESTSEQUENCEERROR;
    }
  }  
  return(LddReturnValue);
}  

/*******************************************************************************
** Function Name        : Dcm_StartRoutinePackSignal                          **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This function packs the output signal value in the  **
**                        routine status record  of start routine response.   **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : Dcm_GblProtocolEndianess       **
**                                                                            **
*******************************************************************************/
#if(DCM_ROUTINE_START_OUTSIGNAL_CONFIGURED == STD_ON)
FUNC(void, DCM_CODE) Dcm_StartRoutinePackSignal(uint16 LusRIDIndex,
P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
{
  P2VAR(Dcm_RoutineConfigType, AUTOMATIC, DCM_VAR)LpRIDTAB;
  P2CONST(Dcm_RoutineSignalInfoType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineSignalInfo;
  P2CONST(Dcm_StartRoutineOutSignalType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineOutSignalInfo;
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpResponseData;
  uint8 LucUint8ByteCount;
  uint8 LucUint16ByteCount;
  uint8 LucUint32ByteCount;
  uint16 LusNumOfSignals;
  uint16 LusSignalCount;
  uint8 LucSignalType;
  Dcm_PackUnpackSignalData LddPackSignal;
  
  LpRIDTAB = &Dcm_GaaRoutineControlConfig[LusRIDIndex];
  LpRoutineSignalInfo = LpRIDTAB->pRoutineSignalInfo;
  
  LucUint8ByteCount = DCM_ZERO;
  LucUint16ByteCount = DCM_ZERO;
  LucUint32ByteCount = DCM_ZERO;
  
  LddPackSignal.ulSignalLength = (uint32)0x00;
  LddPackSignal.ucShiftBits = (uint8)0x00;
  LddPackSignal.ucStartMask = (uint8)0x00;
  LddPackSignal.ucEndMask = (uint8)0x00;
  LddPackSignal.ucSignalType = (uint8)0x00;
  LddPackSignal.ucSignalTypeorSize = (uint8)0x00;
  LddPackSignal.ucSignalSize = (uint8)0x00;
  LddPackSignal.ucSignMask = (uint8)0x00;

  if(NULL_PTR != LpRoutineSignalInfo)
  {
    LusNumOfSignals = LpRoutineSignalInfo->ucNumOfStartRtnOutSignal;
    
    if(NULL_PTR != LpRoutineSignalInfo->pStartRoutineOut)
    {
      LpRoutineOutSignalInfo = LpRoutineSignalInfo->pStartRoutineOut;

      if(NULL_PTR != LpRoutineOutSignalInfo)
      {
        for(LusSignalCount = 0; LusSignalCount < LusNumOfSignals; LusSignalCount++)
        {      
          LucSignalType = 
          ((LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize >> DCM_FOUR) & DCM_SIG_BYTE_MASK_VALUE);
      
          if((LucSignalType == DCM_ONE) || 
          (LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize == 0x50))
          {  
            Dcm_GpRoutineSignalOutDataPtr = &Dcm_GaaRoutineSignalOutData[LucUint8ByteCount];
            LucUint8ByteCount++;
          }
          else if(LucSignalType == DCM_TWO)  
          {
            Dcm_GpRoutineSignalOutDataPtr = &Dcm_GaaRoutineSignalOutData16[LucUint16ByteCount];  
            LucUint16ByteCount++;
          }
          else if(LucSignalType == DCM_FOUR)  
          {
            Dcm_GpRoutineSignalOutDataPtr = &Dcm_GaaRoutineSignalOutData32[LucUint32ByteCount];
            LucUint32ByteCount++;
          }    
          else
          {
            /* To avoid QAC warning */
          } 
          LddPackSignal.ucShiftBits = LpRoutineOutSignalInfo[LusSignalCount].ucNoOfShiftBits;
          LddPackSignal.ucStartMask = LpRoutineOutSignalInfo[LusSignalCount].ucStartMask;
          LddPackSignal.ucEndMask = LpRoutineOutSignalInfo[LusSignalCount].ucEndMask;
          LddPackSignal.ucSignalType = LucSignalType;
          
          if((LpRIDTAB->blRoutineFixedLength == FALSE) &&
          ((LusSignalCount + DCM_ONE) == LusNumOfSignals) && 
          (LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize == 0x50))
          {  
            LddPackSignal.ulSignalLength = Dcm_GusCurrentDataLength;
            Dcm_GusLastSignalLength = (uint16) LpRoutineOutSignalInfo[LusSignalCount].ulSignalLength;
            Dcm_DspServiceProcessingSts.RoutineVariableLength = DCM_TRUE;
          }
          else
          {          
            LddPackSignal.ucSignalTypeorSize = 
            LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize;
            Dcm_GusLastSignalLength = DCM_ZERO;
            Dcm_DspServiceProcessingSts.RoutineVariableLength = DCM_FALSE;
          }  
      
          LpResponseData = 
            &pMsgContext->resData[DCM_THREE + (LpRoutineOutSignalInfo[LusSignalCount].ucSignalStartByte)];
      
          if(LpRoutineOutSignalInfo[LusSignalCount].ucWrFuncIndex < Dcm_Num_Of_SigWrFuncPtr)
          {
            Dcm_GaaSigWrFuncPtr[LpRoutineOutSignalInfo[LusSignalCount].ucWrFuncIndex].pWrFuncPtr
            (LddPackSignal, LpResponseData, 
              (P2VAR(void, AUTOMATIC, DCM_APPL_DATA))Dcm_GpRoutineSignalOutDataPtr);
          }
        }
      }
    }
  }
}
#endif

/*******************************************************************************
** Function Name        : Dcm_StopRoutinePackSignal                           **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This function packs the output signal value in the  **
**                        routine status record  of stop routine response.    **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : Dcm_GblProtocolEndianess       **
**                                                                            **
*******************************************************************************/
#if(DCM_ROUTINE_STOP_OUTSIGNAL_CONFIGURED == STD_ON)
FUNC(void, DCM_CODE) Dcm_StopRoutinePackSignal(uint16 LusRIDIndex, 
P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
{
  P2VAR(Dcm_RoutineConfigType, AUTOMATIC, DCM_VAR)LpRIDTAB;
  P2CONST(Dcm_RoutineSignalInfoType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineSignalInfo;
  P2CONST(Dcm_StopRoutineOutSignalType, AUTOMATIC, DCM_APPL_CONST)
  LpRoutineOutSignalInfo;
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpResponseData;
  uint8 LucUint8ByteCount;
  uint8 LucUint16ByteCount;
  uint8 LucUint32ByteCount;
  uint16 LusNumOfSignals;
  uint16 LusSignalCount;
  uint8 LucSignalType;
  Dcm_PackUnpackSignalData LddPackSignal;
  
  LpRIDTAB = &Dcm_GaaRoutineControlConfig[LusRIDIndex];
  LpRoutineSignalInfo = LpRIDTAB->pRoutineSignalInfo;
  LucUint8ByteCount = DCM_ZERO;
  LucUint16ByteCount = DCM_ZERO;
  LucUint32ByteCount = DCM_ZERO;
  
  LddPackSignal.ulSignalLength = (uint32)0x00;
  LddPackSignal.ucShiftBits = (uint8)0x00;
  LddPackSignal.ucStartMask = (uint8)0x00;
  LddPackSignal.ucEndMask = (uint8)0x00;
  LddPackSignal.ucSignalType = (uint8)0x00;
  LddPackSignal.ucSignalTypeorSize = (uint8)0x00;
  LddPackSignal.ucSignalSize = (uint8)0x00;
  LddPackSignal.ucSignMask = (uint8)0x00;

  if(NULL_PTR != LpRoutineSignalInfo)
  {
    if((LpRoutineSignalInfo->ucNumOfStopRtnOutSignal != DCM_ZERO) &&
       (NULL_PTR != LpRoutineSignalInfo->pStopRoutineOut))
    {  
      /* Initialize pointer to the stop Routine In Signal */
      LpRoutineOutSignalInfo = LpRoutineSignalInfo->pStopRoutineOut;

      if(NULL_PTR != LpRoutineOutSignalInfo)
      {
        /* ucNumOfStopRtnInSignal ->ucNumOfStopRtnOutSignal by YoungJin Yun */
        LusNumOfSignals = LpRoutineSignalInfo->ucNumOfStopRtnOutSignal;
    
        for(LusSignalCount = 0; LusSignalCount < LusNumOfSignals; LusSignalCount++)
        {      
          LucSignalType = 
          ((LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize >> DCM_FOUR) & DCM_SIG_BYTE_MASK_VALUE);
      
          if((LucSignalType == DCM_ONE) || 
          (LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize == 0x50))
          {  
            Dcm_GpRoutineSignalOutDataPtr = &Dcm_GaaRoutineSignalOutData[LucUint8ByteCount];
            LucUint8ByteCount++;
          }
          else if(LucSignalType == DCM_TWO)  
          {
            Dcm_GpRoutineSignalOutDataPtr = &Dcm_GaaRoutineSignalOutData16[LucUint16ByteCount];
            LucUint16ByteCount++;
          }
          else if(LucSignalType == DCM_FOUR)  
          {
            Dcm_GpRoutineSignalOutDataPtr = &Dcm_GaaRoutineSignalOutData32[LucUint32ByteCount];
            LucUint32ByteCount++;
          }
          else
          {
            /* To avoid QAC warning */
          } 
          
          LddPackSignal.ucShiftBits = LpRoutineOutSignalInfo[LusSignalCount].ucNoOfShiftBits;
          LddPackSignal.ucStartMask = LpRoutineOutSignalInfo[LusSignalCount].ucStartMask;
          LddPackSignal.ucEndMask = LpRoutineOutSignalInfo[LusSignalCount].ucEndMask;
          LddPackSignal.ucSignalType = LucSignalType;
        
          if((LpRIDTAB->blRoutineFixedLength == FALSE) &&
          ((LusSignalCount + DCM_ONE) == LusNumOfSignals) && 
          (LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize == 0x50))
          {  
            LddPackSignal.ulSignalLength  = Dcm_GusCurrentDataLength;
            Dcm_GusLastSignalLength = (uint16) LpRoutineOutSignalInfo[LusSignalCount].ulSignalLength;
            Dcm_DspServiceProcessingSts.RoutineVariableLength = DCM_TRUE;
          }
          else
          {          
            LddPackSignal.ucSignalTypeorSize =
            LpRoutineOutSignalInfo[LusSignalCount].ucSignalTypeorSize;
            Dcm_DspServiceProcessingSts.RoutineVariableLength = DCM_FALSE;
            Dcm_GusLastSignalLength = DCM_ZERO;
          }  
        
          LpResponseData = &pMsgContext->resData[DCM_THREE + 
          (LpRoutineOutSignalInfo[LusSignalCount].ucSignalStartByte)];
    
          if(LpRoutineOutSignalInfo[LusSignalCount].ucWrFuncIndex < Dcm_Num_Of_SigWrFuncPtr)
          {
            Dcm_GaaSigWrFuncPtr[LpRoutineOutSignalInfo[LusSignalCount].ucWrFuncIndex].pWrFuncPtr
            (LddPackSignal, LpResponseData, 
            (P2VAR(void, AUTOMATIC, DCM_APPL_DATA))Dcm_GpRoutineSignalOutDataPtr);
          }
        }
      }
    }
  }
}
#endif

/*******************************************************************************
** Function Name        : Dcm_RoutineHandleResponse                           **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This function checks the return value of the        **
**                        start/stop/Requestresult function calls and         **
**                        handles the response transmission accordingly.      **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : Dcm_GddNegRespError            **
**                                                                            **
*******************************************************************************/
FUNC(void, DCM_CODE)Dcm_RoutineHandleResponse(uint8 LucStatus, 
  uint16 LusRIDIndex) 
{
  P2CONST(Dcm_RoutineConfigType, AUTOMATIC, DCM_APPL_CONST)LpRIDTAB;
  uint32 LulLength;
  uint16 LusRoutineIdentifier;
  uint8 LucSubFunction;

  LucSubFunction = Dcm_GstMsgContext.reqData[DCM_ZERO];
  LpRIDTAB = &Dcm_GaaRoutineControlConfig[LusRIDIndex];
  
  if(Dcm_GddOpStatus != DCM_CANCEL)
  {
    if(Dcm_GddNegRespError == DCM_E_POSITIVERESPONSE)
    {
      LusRoutineIdentifier = LpRIDTAB->usRoutineIdentifier;
      if(LucStatus == E_OK)
      {
        Dcm_GddOpStatus = DCM_INITIAL;
        if((LusRoutineIdentifier < (uint16)0xE000U) || (LusRoutineIdentifier > (uint16)0xE0FFU))
        {
          if(LucSubFunction == DCM_ROUTINE_CTRL_START)
          {
            if((LpRIDTAB->blRoutineFixedLength == FALSE) &&
            (Dcm_DspServiceProcessingSts.RoutineVariableLength == DCM_TRUE)) 
            {
              LulLength = ((LpRIDTAB->ulRoutineTotalStartOutLength + 
              Dcm_GusCurrentDataLength) - Dcm_GusLastSignalLength);
            }
            else
            {
              LulLength = LpRIDTAB->ulRoutineTotalStartOutLength;
            }
          }
          else if(LucSubFunction == DCM_ROUTINE_CTRL_STOP)
          {
            if((LpRIDTAB->blRoutineFixedLength == FALSE) &&
            (Dcm_DspServiceProcessingSts.RoutineVariableLength == DCM_TRUE))
            {
              LulLength = ((LpRIDTAB->ulRoutineTotalStopOutLength + 
              Dcm_GusCurrentDataLength) - Dcm_GusLastSignalLength);
            }
            else
            {
              LulLength = LpRIDTAB->ulRoutineTotalStopOutLength;
            }
          }
          else
          {
            if((LpRIDTAB->blRoutineFixedLength == FALSE) &&
            (Dcm_DspServiceProcessingSts.RoutineVariableLength == DCM_TRUE))
            {
              LulLength = ((LpRIDTAB->ulRoutineTotalReqResOutLength + 
              Dcm_GusCurrentDataLength) - Dcm_GusLastSignalLength);
            }
            else
            {
              LulLength = LpRIDTAB->ulRoutineTotalReqResOutLength;
            }
          }            
          Dcm_GstMsgContext.resDataLen = DCM_THREE + LulLength;
          Dcm_GstMsgContext.resData[DCM_ZERO] = Dcm_GstMsgContext.reqData[DCM_ZERO];
          Dcm_GstMsgContext.resData[DCM_ONE] = Dcm_GstMsgContext.reqData[DCM_ONE];
          Dcm_GstMsgContext.resData[DCM_TWO] = Dcm_GstMsgContext.reqData[DCM_TWO];
          Dcm_ServicePendingStatus.ucRoutinePendingStatus = DCM_FALSE;
          Dcm_ServiceForcePendingStatus.ucRoutineForcePendingStatus = DCM_FALSE;
        }
        else
        {
            /* To avoid QAC Warnings */
        }
      }
      else if(LucStatus == (uint8) DCM_E_PENDING)
      {
        Dcm_GddOpStatus = DCM_PENDING;
        /* Set response pending flag to True */
        Dcm_ServicePendingStatus.ucRoutinePendingStatus = DCM_TRUE;
      }
      else if(LucStatus == (uint8) DCM_E_FORCE_RCRRP)
      {
        Dcm_GddOpStatus = DCM_FORCE_RCRRP_OK;
        
        /* Set Force responsepending flag to True */
        Dcm_ServiceForcePendingStatus.ucRoutineForcePendingStatus = DCM_TRUE;

        Dcm_GusMaxNoOfForceRespPend++;
        
        if(Dcm_GusMaxNoOfForceRespPend > (uint16)DCM_DIAG_RESP_MAX_NUM_RESPEND)
        {
          Dcm_GddOpStatus = DCM_CANCEL;
          Dcm_GddNegRespError = DCM_E_GENERALREJECT;
          /* Call to cancel the operation , so return value is ignored */
          (void)Dcm_RoutineSignalFunction(Dcm_GucRoutineSubFunction, Dcm_GusRoutineIdentifier);
          Dcm_ServiceForcePendingStatus.ucRoutineForcePendingStatus = DCM_FALSE;      
        }
        else
        {
          /* Update the negative response service Id in the response buffer */
          Dcm_GaaResponseBuf[DCM_ZERO] = DCM_NEGATIVE_RESPONSE_SID;
          /* Update the service Id in the response buffer */
          Dcm_GaaResponseBuf[DCM_ONE] =
          ((Dcm_GstMsgContext.idContext) & (DCM_BIT6_AND_MASK));
          /* Update the NRC in the response buffer */
          Dcm_GaaResponseBuf[DCM_TWO] =
          DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING;
          /* Update the bit flag for negative response to TRUE */
          Dcm_TxRespStatus.ucNegResp = DCM_TRUE;

          Dcm_GblRespPendConfirmation = DCM_FALSE;
          /* Invoke the internal function to transmit negative response */
          Dcm_DslPduRTransmit();    
        }
      }
      else
      {
        Dcm_GddNegRespError = DCM_E_CONDITIONSNOTCORRECT;
      }
    }
  
    if((Dcm_ServicePendingStatus.ucRoutinePendingStatus == DCM_FALSE) &&
    (Dcm_ServiceForcePendingStatus.ucRoutineForcePendingStatus == DCM_FALSE))
    {
      Dcm_GusMaxNoOfForceRespPend = DCM_ZERO;
      Dcm_ServicePendingStatus.ucRoutineReqFunc = DCM_FALSE;
      Dcm_GusLastSignalLength = DCM_ZERO;
      
      /* Send response from main function */
      Dcm_GblSendResponse = DCM_TRUE; 
    }
    else
    {
      Dcm_GucRoutineSubFunction = Dcm_GstMsgContext.reqData[DCM_ZERO] & DCM_SUBFUNCTION_MASK;
      Dcm_GusRoutineIdentifier = LpRIDTAB->usRoutineIdentifier;
      Dcm_GusRIDIndex = LusRIDIndex;
    }  
  }
  else
  {
    /* Reset OpStatus */
    Dcm_GddOpStatus = DCM_INITIAL;
  }
}    

/*******************************************************************************
** Function Name        : Dcm_DspHandleOBDRoutineControl                      **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This function invokes the corresponding function    **
**                        configured for RID and gets the output signal value **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : None                           **
**                                                                            **
*******************************************************************************/
#if(DCM_OBD_REQ_CTLRL_ONBOADSYSTEM_SERVICE == STD_ON)
FUNC(void, DCM_CODE) Dcm_DspHandleOBDRoutineControl(
P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_APPL_DATA) pMsgContext)
{
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpReqResData;
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpTxBuffer;
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpInBuffer;
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) LpOutBuffer;
  uint8 LucReqBuffer[DCM_ONE];
  uint8 LucTIDValue;
  uint8 LucTIDIndex;
  uint8 LucMix_DemRPort;
  Std_ReturnType LddReturnValue = E_NOT_OK;
  
  /* Get the pointer to the request data buffer */
  LpReqResData = pMsgContext->reqData;  
  LucTIDValue = LpReqResData[DCM_TWO];    
  LucReqBuffer[DCM_ZERO] = LpReqResData[DCM_TWO];  
  LucMix_DemRPort = DCM_EIGHT;
  
  /* It scans for all PIDs */
  /* To find whether the PIDs belongs to Availability PIDs or Dem or RPort */
  LddReturnValue = Dcm_DspGetAvailibiltyIDStatus(DCM_GET_TID,
  &LucReqBuffer[DCM_ZERO], DCM_ONE, LucMix_DemRPort);
  
  /* Validate DCM_AVAIL_ID for response length */
  if(LddReturnValue == DCM_AVAIL_ID)
  {
    /* Total response = Number of PIDs + (Number of PIDs) * four */
    LpTxBuffer = &pMsgContext->resData[DCM_THREE];
    Dcm_DspReadOBD_AvlInfo(&LucReqBuffer[DCM_ZERO], LpTxBuffer,
    DCM_FOUR, DCM_ONE, DCM_GET_TID);
    pMsgContext->resDataLen = DCM_FIVE;     
  }
  else if(LddReturnValue == DCM_OTHER_PID)
  {    
    LddReturnValue = Dcm_GetIDIndex(DCM_GET_TID, LucTIDValue, &LucTIDIndex);
    if(LddReturnValue == E_OK)
    {
      LpOutBuffer = &pMsgContext->resData[DCM_THREE];
      LpInBuffer = &pMsgContext->reqData[DCM_THREE];
      LddReturnValue = Dcm_GaaRequestControlConfig[LucTIDIndex].pReqControlFnc(LpOutBuffer, LpInBuffer);
  
      if(LddReturnValue == E_OK)
      {
        pMsgContext->resDataLen = DCM_ONE +
        Dcm_GaaRequestControlConfig[LucTIDIndex].ucRequestControlOutBufferSize;
      }
      else
      {
        Dcm_GddNegRespError = DCM_E_CONDITIONSNOTCORRECT;
      }      
    }
    else
    {
      Dcm_GddNegRespError = DCM_E_REQUESTOUTOFRANGE;
    }
  }
  else
  {
    Dcm_GddNegRespError = DCM_E_REQUESTOUTOFRANGE;
  }
}
#endif

/*******************************************************************************
** Function Name        : Dcm_RoutineSignalFunction                           **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This function invokes the corresponding function    **
**                        configured for RID and gets the output signal value **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : None                           **
**                                                                            **
*******************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_RoutineSignalFunction
  (uint8 LucSubFunction, uint16 LusRoutineIdentifier)
{
  Dcm_OpStatusType LddOpStatus;
  Dcm_NegativeResponseCodeType LddNegativeErrorCode;
  Std_ReturnType LddReturnValue;
  /* Update OpStatus */
  LddNegativeErrorCode = DCM_E_POSITIVERESPONSE;
  LddOpStatus = Dcm_GddOpStatus;
  
  if(LucSubFunction == DCM_ROUTINE_CTRL_START)
  {
    switch(LusRoutineIdentifier)
    {
      
      case 512 :

				LddReturnValue = Rte_Call_RoutineServices_RID_0200h_CalibrationActuator_Start(
				Dcm_GaaRoutineSignalInData[0],
				LddOpStatus,
				 &Dcm_GaaRoutineSignalOutData[0],
				&LddNegativeErrorCode);
				break;

      default:   LddReturnValue = E_NOT_OK;
      break;
    }
  }
  else if(LucSubFunction == DCM_ROUTINE_CTRL_STOP)
  {
    switch(LusRoutineIdentifier)
    {
      
      case 512 :
				LddReturnValue = Rte_Call_RoutineServices_RID_0200h_CalibrationActuator_Stop(
				 Dcm_GaaRoutineSignalInData[0],
				LddOpStatus,
				 &Dcm_GaaRoutineSignalOutData[0],
				&LddNegativeErrorCode);
				break;

      default:   LddReturnValue = E_NOT_OK;
      break;
    }
  }
  else
  {
    switch(LusRoutineIdentifier)
    {
      
      case 512 :
				LddReturnValue = Rte_Call_RoutineServices_RID_0200h_CalibrationActuator_RequestResults(LddOpStatus,
				 &Dcm_GaaRoutineSignalOutData[0],
				&LddNegativeErrorCode);
				break;

      default:   LddReturnValue = E_NOT_OK;
      break;
    }
  }
  
  if(LddReturnValue == E_NOT_OK)
  {
    /* Update the error code value in the global variable */
    Dcm_GddNegRespError = LddNegativeErrorCode;
  } 
  
  return(LddReturnValue);
}

/*******************************************************************************
** Function Name        : Dcm_RoutineMainFunction                             **
**                                                                            **
** Service ID           : NA                                                  **
**                                                                            **
** Description          : This service is used for processing the tasks of    **
**                        the main loop for routine services.                 **
**                        It is called periodically as cyclic task by the     **
**                        software system.                                    **
**                                                                            **
** Re-entrancy          : Non-Reentrant                                       **
**                                                                            **
** Input Parameters     : pMsgContext                                         **
**                                                                            **
** Output Parameters    : None                                                **
**                                                                            **
** Return parameter     : None                                                **
**                                                                            **
** Preconditions        : None                                                **
**                                                                            **
** Remarks              : Global Variable(s) : None                           **
**                                                                            **
*******************************************************************************/
FUNC(void, DCM_CODE) Dcm_RoutineMainFunction(void)
{
  Std_ReturnType LddReturnValue = E_NOT_OK;
  
  /* SWS_Dcm_00528]  If the value DCM_E_FORCE_RCRRP is returned  from an 
   * operation using Dcm_OpStatusType, the DCM shall invoke the transmit request for 
   * RCR-RP (NRC 0x78 transmission) and the DCM shall not realize further invocation 
   * of the operation till RCR-RP is transmitted.
   *    
   * [SWS_Dcm_00529]  After transmit confirmation of a RCR-RP transmitted on the 
   * context of [SWS_Dcm_00528, the DCM calls, from Dcm_MainFunction (due to call 
   * context), the operation again with OpStatus = DCM_FORCE_RCRRP_OK. */
  if((Dcm_ServicePendingStatus.ucRoutinePendingStatus == DCM_TRUE) ||
    ((Dcm_ServiceForcePendingStatus.ucRoutineForcePendingStatus == DCM_TRUE) &&
     (Dcm_GblRespPendConfirmation == DCM_TRUE)))
  {
    Dcm_ServicePendingStatus.ucRoutinePendingStatus = DCM_FALSE;
    Dcm_ServiceForcePendingStatus.ucRoutineForcePendingStatus = DCM_FALSE;
    Dcm_GblRespPendConfirmation = DCM_FALSE;

    if(Dcm_GusRIDIndex < Dcm_Num_Of_Gaa_Routine_Control_Config)
    {
      LddReturnValue = Dcm_Internal_DcmRoutineControl(Dcm_GusRoutineIdentifier, Dcm_GusRIDIndex, &Dcm_GstMsgContext);
    }

    (void)Dcm_RoutineHandleResponse((uint8)LddReturnValue, Dcm_GusRIDIndex);
  }
}
#define DCM_STOP_SEC_CODE
#include "MemMap.h"
#endif

/* polyspace:end<MISRA-C:13.7:Not a defect:Justify with annotations> It has not any impact. */
/* polyspace:end<MISRA-C:8.10:Not a defect:Justify with annotations> Whether the Dcm api function is required internal or external linkage, depends on user configuration */
/* polyspace:end<RTE: IDP : Not a defect : No Action Planned > address pointed to function is correct */
/* polyspace:end<RTE: NIV : Not a defect : No Action Planned > initialized variable */
/* polyspace:end<RTE: NIP : Not a defect : No Action Planned > pointer is not null */
/* polyspace:end<RTE: COR : Not a defect : No Action Planned > function ptr points to a valid function */

/*******************************************************************************
**                      End of File                                           **
*******************************************************************************/
